
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Format Message Modeling &#8212; Netzob Documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="State Machine Modeling" href="statemachinespec.html" />
    <link rel="prev" title="Installation of Netzob" href="../installation/python.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/zoby.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Netzob Documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Netzob documentation
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Installation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../installation/python.html">
   Installation of Netzob
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Protocol Modelization
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Format Message Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="statemachinespec.html">
   State Machine Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="protospec.html">
   Protocol Modeling
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Traffic Generation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="trafficgeneration.html">
   Sending and Receiving Messages
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="actor.html">
   Visiting a State Machine with an Actor
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fuzzing
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="fuzzing.html">
   Fuzzing Message Format
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fuzzing_automata.html">
   Fuzzing Automata
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/language_specification/dataspec.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#format-message-modeling-concepts">
   Format Message Modeling Concepts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#definitions-symbol-field-variable">
     Definitions: Symbol, Field, Variable
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#abstraction-and-specialization-of-symbols">
     Abstraction and Specialization of Symbols
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-data-types">
   Modeling Data Types
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#data-types-api">
     Data Types API
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#data-types">
     Data Types
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#integer-type">
       Integer Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blob-raw-type">
       BLOB / Raw Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#hexastring-type">
       HexaString Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#string-type">
       String Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bitarray-type">
       BitArray Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ipv4-type">
       IPv4 Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#timestamp-type">
       Timestamp Type
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-fields">
   Modeling Fields
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-variables">
   Modeling Variables
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-data-variables">
   Modeling Data Variables
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-node-variables">
   Modeling Node Variables
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aggregate-domain">
     Aggregate Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#alternate-domain">
     Alternate Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#repeat-domain">
     Repeat Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optional-domain">
     Optional Domain
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-fields-with-relationship-variables">
   Modeling Fields with Relationship Variables
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#value-relationships">
     Value Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#size-relationships">
     Size Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#padding-relationships">
     Padding Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#checksum-relationships">
     Checksum Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hash-relationships">
     Hash Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hmac-relationships">
     HMAC Relationships
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-symbols">
   Modeling Symbols
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuring-symbol-content">
   Configuring Symbol Content
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#setting-field-values">
     Setting Field Values
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#symbol-with-no-content">
     Symbol with no Content
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relationships-between-symbols-and-the-environment">
   Relationships between Symbols and the Environment
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#persistence-during-specialization-and-abstraction-of-symbols">
   Persistence during Specialization and Abstraction of Symbols
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Format Message Modeling</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#format-message-modeling-concepts">
   Format Message Modeling Concepts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#definitions-symbol-field-variable">
     Definitions: Symbol, Field, Variable
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#abstraction-and-specialization-of-symbols">
     Abstraction and Specialization of Symbols
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-data-types">
   Modeling Data Types
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#data-types-api">
     Data Types API
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#data-types">
     Data Types
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#integer-type">
       Integer Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blob-raw-type">
       BLOB / Raw Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#hexastring-type">
       HexaString Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#string-type">
       String Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bitarray-type">
       BitArray Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ipv4-type">
       IPv4 Type
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#timestamp-type">
       Timestamp Type
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-fields">
   Modeling Fields
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-variables">
   Modeling Variables
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-data-variables">
   Modeling Data Variables
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-node-variables">
   Modeling Node Variables
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aggregate-domain">
     Aggregate Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#alternate-domain">
     Alternate Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#repeat-domain">
     Repeat Domain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optional-domain">
     Optional Domain
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-fields-with-relationship-variables">
   Modeling Fields with Relationship Variables
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#value-relationships">
     Value Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#size-relationships">
     Size Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#padding-relationships">
     Padding Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#checksum-relationships">
     Checksum Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hash-relationships">
     Hash Relationships
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hmac-relationships">
     HMAC Relationships
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-symbols">
   Modeling Symbols
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuring-symbol-content">
   Configuring Symbol Content
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#setting-field-values">
     Setting Field Values
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#symbol-with-no-content">
     Symbol with no Content
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relationships-between-symbols-and-the-environment">
   Relationships between Symbols and the Environment
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#persistence-during-specialization-and-abstraction-of-symbols">
   Persistence during Specialization and Abstraction of Symbols
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="format-message-modeling">
<span id="dataspec"></span><span id="id1"></span><h1>Format Message Modeling<a class="headerlink" href="#format-message-modeling" title="Permalink to this headline">#</a></h1>
<p>The Netzob Description Language (ZDL) is the API exposed by the Netzob library
to model data structures employed in communication protocols.
This textual language has been designed in order to be easily understandable
by a human. It enables the user to describe a protocol through dedicated
<em>*.zdl</em> files, which are independent of the API and core of the library.
The ZDL language has been designed with attention to its expressiveness.
In this chapter, firstly, the main concepts of the ZDL language are presented,
then its expressiveness in terms of data types,
constraints and relationships are explained.</p>
<section id="format-message-modeling-concepts">
<h2>Format Message Modeling Concepts<a class="headerlink" href="#format-message-modeling-concepts" title="Permalink to this headline">#</a></h2>
<section id="definitions-symbol-field-variable">
<h3>Definitions: Symbol, Field, Variable<a class="headerlink" href="#definitions-symbol-field-variable" title="Permalink to this headline">#</a></h3>
<p>In the Netzob library, the set of valid messages and their formats are
represented through <strong>symbols</strong>. A symbol represents all the messages
that share a similar objective from a protocol perspective.  For
example, the HTTP_GET symbol would describe any HTTP request with the
GET method being set. A symbol can be specialized into a context-valid
message and a message can be abstracted into a symbol.</p>
<p>A <strong>field</strong> describes a chunk of the symbol and is defined by a
<strong>definition domain</strong>, representing the set of values the field handles.
To support complex domains, a definition domain is represented by a tree where
each vertex is a <strong>Variable</strong>. There are three kinds of variables:</p>
<ul class="simple">
<li><p><strong>Data variables</strong>, which describes data whose value is of a given <strong>type</strong>. Various types are provided with the library, such as String, Integer, Raw and BitArray.</p></li>
<li><p><strong>Relationship variables</strong>, which make it possible to model a relationship between a variable and a list of variables or fields. Besides, relationships can be done between fields of different symbols, thus making it possible to model both <strong>intra-symbol relationships</strong> and <strong>inter-symbol relationships</strong>.</p></li>
<li><p><strong>Node variables</strong>, which accept one or more children variables.</p></li>
</ul>
<p>Node variables can be used to construct complex definition domains,
such as:</p>
<ul class="simple">
<li><p><strong>Aggregate node variable</strong>, which can be used to model a concatenation of
variables.</p></li>
<li><p><strong>Alternate node variable</strong>, which can be used to model an alternative of
multiple variables.</p></li>
<li><p><strong>Repeat node variable</strong>, which can be used to model a repetition of a
variable.</p></li>
<li><p><strong>Optional node variable</strong>, which can be used to model a variable
that may or may not be present.</p></li>
</ul>
<p>As an illustration of these concepts, the following figure presents the
definition of a Symbol structured with three Fields.
The first field contains an alternative between String Data with a constant
string and Integer Data with a constant value. The second field is String
Data with a variable length string.
The third field depicts an Integer whose value is the size of the second string.</p>
<figure class="align-center" id="id4">
<img alt="../_images/netzob_vocabulary_model.png" src="../_images/netzob_vocabulary_model.png" />
<figcaption>
<p><span class="caption-text">Example of Symbol definition and relationships with Field and Variable objects.</span><a class="headerlink" href="#id4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="abstraction-and-specialization-of-symbols">
<h3>Abstraction and Specialization of Symbols<a class="headerlink" href="#abstraction-and-specialization-of-symbols" title="Permalink to this headline">#</a></h3>
<p>The use of a symbolic model is required to represent the message formats of a protocol in a compact way. However, as the objective of this platform is to analyze the robustness of a target implementation, this implies that the testing tool should be able to exchange messages with this target. We therefore need to abstract received messages into symbols that can be used by the protocol model. Conversely, we also need to specialize symbols produced by the protocol model into valid messages. To achieve this, we use an <strong>abstraction</strong> method (<em>ABS</em>) and a <strong>specialization</strong> (<em>SPE</em>) method. As illustrated in the following figure, these methods play the role of an interface between the symbolic protocol model and a communication channel on which concrete messages transit.</p>
<figure class="align-center" id="id5">
<img alt="../_images/abstractionAndSpecialization.png" src="../_images/abstractionAndSpecialization.png" />
<figcaption>
<p><span class="caption-text">Abstraction (ABS) and Specialization (SPE) methods are interfaces between the protocol symbols and the wire messages.</span><a class="headerlink" href="#id5" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To compute or verify the constraints and relationships that
participate in the definition of the fields, the library relies on a
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a>. This memory stores the value of previously captured or emitted
fields. More precisely, the memory contains all the variables that are
needed according to the field definition during the abstraction and
specialization processes.</p>
</section>
</section>
<section id="modeling-data-types">
<h2>Modeling Data Types<a class="headerlink" href="#modeling-data-types" title="Permalink to this headline">#</a></h2>
<p>The library enables the modeling of the following data types:</p>
<ul class="simple">
<li><p><strong>Integer</strong>: The Integer type is a wrapper for the Python integer object with the capability to express more constraints regarding the sign, endianness and unit size.</p></li>
<li><p><strong>HexaString</strong>: The HexaString type makes it possible to describe a sequence of bytes of arbitrary size, with a hexastring notation (e.g. <code class="docutils literal notranslate"><span class="pre">aabbcc</span></code>).</p></li>
<li><p><strong>BLOB / Raw</strong>: The Raw type makes it possible to describe a sequence of bytes of arbitrary size, with a raw notation (e.g. <code class="docutils literal notranslate"><span class="pre">\xaa\xbb\xcc</span></code>).</p></li>
<li><p><strong>String</strong>: The String type makes it possible to describe a field that contains sequence of String characters.</p></li>
<li><p><strong>BitArray</strong>: The BitArray type makes it possible to describe a field that contains a sequence of bits of arbitrary size.</p></li>
<li><p><strong>IPv4</strong>: The IPv4 type makes it possible to encode a raw Python in an IPv4 representation, and conversely to decode an IPv4 representation into a raw object.</p></li>
<li><p><strong>Timestamp</strong>: The Timestamp type makes it possible to define dates in a specific format (such as Windows, Unix or MacOS X formats).</p></li>
</ul>
<section id="data-types-api">
<h3>Data Types API<a class="headerlink" href="#data-types-api" title="Permalink to this headline">#</a></h3>
<p>Each data type provides the following API:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.AbstractType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AbstractType</span></span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#AbstractType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="Permalink to this definition">#</a></dt>
<dd><p>AbstractType is the abstract class of all the classes that represent Netzob types.</p>
<p>A type defines a definition domain as a unique value or specified
with specific rules.  For instance, an integer under a specific
interval, a string with a number of chars and an IPv4 of a
specific netmask.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.AbstractType.convert">
<span class="sig-prename descclassname"><span class="pre">AbstractType.</span></span><span class="sig-name descname"><span class="pre">convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typeClass</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#AbstractType.convert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType.convert" title="Permalink to this definition">#</a></dt>
<dd><p>Convert the current data type in a destination type specified in
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>typeClass</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>, required) – The Netzob type class to which the current data
must be converted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The converted current value in the specified data type.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">uint8</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">Raw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">b&#39;*&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.AbstractType.generate">
<span class="sig-prename descclassname"><span class="pre">AbstractType.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#AbstractType.generate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType.generate" title="Permalink to this definition">#</a></dt>
<dd><p>This method should generate data that respects the current data type.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The data produced.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">160</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">160</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;aabbccdd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="go">bitarray(&#39;10101010101110111100110011011101&#39;)</span>
</pre></div>
</div>
</dd></dl>

<p>Some data types can have specific attributes regarding their endianness, sign and unit size. Values supported for those attributes are available through Python enumerations:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Endianness">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Endianness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#Endianness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="Permalink to this definition">#</a></dt>
<dd><p>Enum class used to specify the endianness of a type.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Endianness.BIG">
<span class="sig-name descname"><span class="pre">BIG</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'big'</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness.BIG" title="Permalink to this definition">#</a></dt>
<dd><p>Endianness.BIG can be used to specify a BIG endianness of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Endianness.LITTLE">
<span class="sig-name descname"><span class="pre">LITTLE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'little'</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness.LITTLE" title="Permalink to this definition">#</a></dt>
<dd><p>Endianness.LITTLE can be used to specify a LITTLE endianness of a type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Sign">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#Sign"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign" title="Permalink to this definition">#</a></dt>
<dd><p>Enum class used to specify the sign of a type.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Sign.SIGNED">
<span class="sig-name descname"><span class="pre">SIGNED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'signed'</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign.SIGNED" title="Permalink to this definition">#</a></dt>
<dd><p>Sign.SIGNED can be used to specify a SIGNED sign of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.Sign.UNSIGNED">
<span class="sig-name descname"><span class="pre">UNSIGNED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'unsigned'</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign.UNSIGNED" title="Permalink to this definition">#</a></dt>
<dd><p>Sign.UNSIGNED can be used to specify a UNSIGNED sign of a type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnitSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/AbstractType.html#UnitSize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize" title="Permalink to this definition">#</a></dt>
<dd><p>Enum class used to specify the unit size of a type (i.e. the space in bits that a unitary element takes up).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_1">
<span class="sig-name descname"><span class="pre">SIZE_1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_1" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_1 can be used to specify a 1-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_16">
<span class="sig-name descname"><span class="pre">SIZE_16</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">16</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_16" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_16 can be used to specify a 16-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_24">
<span class="sig-name descname"><span class="pre">SIZE_24</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">24</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_24" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_24 can be used to specify a 24-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_32">
<span class="sig-name descname"><span class="pre">SIZE_32</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">32</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_32" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_32 can be used to specify a 32-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_4">
<span class="sig-name descname"><span class="pre">SIZE_4</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_4" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_4 can be used to specify a 4-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_64">
<span class="sig-name descname"><span class="pre">SIZE_64</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">64</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_64" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_64 can be used to specify a 64-bit unit size of a type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_8">
<span class="sig-name descname"><span class="pre">SIZE_8</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">8</span></em><a class="headerlink" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize.SIZE_8" title="Permalink to this definition">#</a></dt>
<dd><p>UnitSize.SIZE_8 can be used to specify a 8-bit unit size of a type.</p>
</dd></dl>

</dd></dl>

</section>
<section id="data-types">
<h3>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">#</a></h3>
<p>Supported data types are described in detail in this chapter.</p>
<section id="integer-type">
<span id="id2"></span><h4>Integer Type<a class="headerlink" href="#integer-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of an integer is done through the Integer class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.Integer.Integer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">UnitSize.SIZE_16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endianness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Endianness.BIG</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Sign.SIGNED</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/Integer.html#Integer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.Integer.Integer" title="Permalink to this definition">#</a></dt>
<dd><p>The Integer class represents an integer, with the
capability to express constraints regarding the sign, the
endianness and the unit size.</p>
<p>The Integer constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains a fixed integer. If None, the constructed Integer will represent an interval of values (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code> parameter).</p></li>
<li><p><strong>interval</strong> (a tuple with the min and the max values specified as <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains an interval of permitted values. This information is used to compute the storage size of the Integer. If None, the interval will range from the minimum value to the maximum value that an integer can encode, according to its unit size, endianness and sign attributes.</p></li>
<li><p><strong>unitSize</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize" title="netzob.Model.Vocabulary.Types.AbstractType.UnitSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitSize</span></code></a>, optional) – <p>The unitsize, in bits, of the storage area used to encode the integer. Values must be one of UnitSize.SIZE_*.</p>
<p>The following unit sizes are available:</p>
<ul>
<li><p>UnitSize.SIZE_8</p></li>
<li><p>UnitSize.SIZE_16 (default unit size)</p></li>
<li><p>UnitSize.SIZE_24</p></li>
<li><p>UnitSize.SIZE_32</p></li>
<li><p>UnitSize.SIZE_64</p></li>
</ul>
</p></li>
<li><p><strong>endianness</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="netzob.Model.Vocabulary.Types.AbstractType.Endianness"><code class="xref py py-class docutils literal notranslate"><span class="pre">Endianness</span></code></a>, optional) – <p>The endianness of the value.</p>
<p>The following endiannesses are available:</p>
<ul>
<li><p>Endianness.BIG (default endianness)</p></li>
<li><p>Endianness.LITTLE</p></li>
</ul>
</p></li>
<li><p><strong>sign</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign" title="netzob.Model.Vocabulary.Types.AbstractType.Sign"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sign</span></code></a>, optional) – <p>The sign of the value.</p>
<p>The following signs are available:</p>
<ul>
<li><p>Sign.SIGNED (default sign)</p></li>
<li><p>Sign.UNSIGNED</p></li>
</ul>
</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The Integer class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size of the expected data type defined by a tuple (min integer, max integer).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>unitSize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The unitSize of the current value.</p></li>
<li><p><strong>endianness</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The endianness of the current value.</p></li>
<li><p><strong>sign</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The sign of the current value.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p><strong>Examples of Integer object instantiations</strong></p>
<p>The creation of an Integer with no parameter will create a signed,
big-endian integer of 16 bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>  
<span class="go">b&#39;\x94\xba&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define an integer encoded in
sequences of 8 bits and with a constant value of 12 (thus producing
<code class="docutils literal notranslate"><span class="pre">\x0c</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x0c&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define an integer encoded in
sequences of 32 bits and with a constant value of 12 (thus
producing <code class="docutils literal notranslate"><span class="pre">\x00\x00\x00\x0c</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x00\x0c&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define an integer encoded in
sequences of 32 bits in little endian with a constant value of 12
(thus producing <code class="docutils literal notranslate"><span class="pre">\x0c\x00\x00\x00</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_32</span><span class="p">,</span> <span class="n">endianness</span><span class="o">=</span><span class="n">Endianness</span><span class="o">.</span><span class="n">LITTLE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x0c\x00\x00\x00&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define a signed integer
encoded in sequences of 16 bits with a constant value of -12 (thus
producing <code class="docutils literal notranslate"><span class="pre">\xff\xf4</span></code>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">Sign</span><span class="o">.</span><span class="n">SIGNED</span><span class="p">,</span> <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xff\xf4&#39;</span>
</pre></div>
</div>
<p><strong>Examples of pre-defined Integer types</strong></p>
<p>For convenience, common specific integer types are also available, with
pre-defined values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">unitSize</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">sign</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">endianness</span></code>
attributes. They are used to shorten calls of singular definitions.</p>
<p>Available big-endian pre-defined Integer types are:</p>
<ul class="simple">
<li><p>int8be (or int8)</p></li>
<li><p>int16be (or int16)</p></li>
<li><p>int24be (or int24)</p></li>
<li><p>int32be (or int32)</p></li>
<li><p>int64be (or int64)</p></li>
<li><p>uint8be (or uint8)</p></li>
<li><p>uint16be (or uint16)</p></li>
<li><p>uint24be (or uint24)</p></li>
<li><p>uint32be (or uint32)</p></li>
<li><p>uint64be (or uint64)</p></li>
</ul>
<p>Available little-endian pre-defined Integer types are:</p>
<ul class="simple">
<li><p>int8le</p></li>
<li><p>int16le</p></li>
<li><p>int24le</p></li>
<li><p>int32le</p></li>
<li><p>int64le</p></li>
<li><p>uint8le</p></li>
<li><p>uint16le</p></li>
<li><p>uint24le</p></li>
<li><p>uint32le</p></li>
<li><p>uint64le</p></li>
</ul>
<p>For example, a <em>16-bit little-endian unsigned</em> Integer is classically defined
like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_16</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">sign</span><span class="o">=</span><span class="n">Sign</span><span class="o">.</span><span class="n">UNSIGNED</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">endianness</span><span class="o">=</span><span class="n">Endianness</span><span class="o">.</span><span class="n">LITTLE</span><span class="p">)</span>
</pre></div>
</div>
<p>Could also be called in an equivalent form:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">uint16le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>There is an equivalence between these two integers, for every
internal value of the type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_16</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">sign</span><span class="o">=</span><span class="n">Sign</span><span class="o">.</span><span class="n">UNSIGNED</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">endianness</span><span class="o">=</span><span class="n">Endianness</span><span class="o">.</span><span class="n">LITTLE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i2</span> <span class="o">=</span> <span class="n">uint16le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span>
<span class="go">(42, 42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But a comparison between two specific integers of different kinds will
always fail, even if their values look equivalent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">=</span> <span class="n">uint16le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i2</span> <span class="o">=</span> <span class="n">uint32le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span>
<span class="go">False</span>
</pre></div>
</div>
<p>And even when the concrete value seems identical, the integer
objects are not:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">=</span> <span class="n">uint16le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i2</span> <span class="o">=</span> <span class="n">int16le</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span>
<span class="go">(42, 42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
<span class="go">Integer(42) Integer(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span>
<span class="go">False</span>
</pre></div>
</div>
<p><strong>Integer raw representations</strong></p>
<p>The following examples show how to create integers with different
raw representation, depending on data type attributes. In these
examples, we create a 16-bit little endian, a 16-bit big endian,
a 32-bit little endian and a 32-bit big endian:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int16le</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xd2\x04&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int16be</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x04\xd2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int32le</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xd2\x04\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int32be</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x04\xd2&#39;</span>
</pre></div>
</div>
<p><strong>Representation of Integer type objects</strong></p>
<p>The following examples show the representation of Integer objects
with and without a constant value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">int16le</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">Integer(12)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">int16le</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">Integer(-32768,32767)</span>
</pre></div>
</div>
<p><strong>Encoding of Integer type objects</strong></p>
<p>The following examples show the encoding of Integer objects with
and without a constant value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">int32le</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&#39;12&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">int32le</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&#39;None&#39;</span>
</pre></div>
</div>
<p><strong>Using a default value</strong></p>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">uint8</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x03&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x04&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="blob-raw-type">
<h4>BLOB / Raw Type<a class="headerlink" href="#blob-raw-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of a BLOB type is made through the Raw class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.Raw.Raw">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Raw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbBytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/Raw.html#Raw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.Raw.Raw" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines a Raw type.</p>
<p>The Raw type describes a sequence of bytes of arbitrary
size.</p>
<p>The Raw constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, optional) – This parameter is used to describe a domain that contains a fixed sequence of bytes. If None, the constructed Raw will accept a random sequence of bytes, whose size may be specified (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBytes</span></code> parameter).</p></li>
<li><p><strong>nbBytes</strong> (an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a tuple with the min and the max sizes specified as <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains an amount of bytes. This amount can be fixed or represented with an interval. If None, the accepted sizes will range from 0 to 8192.</p></li>
<li><p><strong>alphabet</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, optional) – The alphabet can be used to limit the bytes that can participate in the domain value. The default value is None.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBytes</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">alphabet</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The Raw class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The internal size (in bits) of the expected data type defined by a tuple (min, max).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>alphabet</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>) – The alphabet can be used to limit the bytes that can participate in the domain value.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p>The creation of a Raw type with no parameter will create a bytes
object whose length ranges from 0 to 8192:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">533</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">7738</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">5505</span>
</pre></div>
</div>
<p>The following example shows how to define a six-byte long raw
object, and the use of the generation method to produce a
value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">6</span>
</pre></div>
</div>
<p>It is possible to define a range regarding the valid size of the
raw object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">20</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example shows the specification of a raw constant:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">Raw(b&#39;\x01\x02\x03&#39;)</span>
</pre></div>
</div>
<p>The alphabet optional argument can be used to limit the bytes that
can participate in the domain value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="sa">b</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;o&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b&#39;otoottootottottooooooottttooot&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>  <span class="c1"># extract distinct characters</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">t</span>
<span class="go">o</span>
</pre></div>
</div>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x01\x02&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="hexastring-type">
<h4>HexaString Type<a class="headerlink" href="#hexastring-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of a hexastring type is made through the HexaString class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.HexaString.HexaString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HexaString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbBytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/HexaString.html#HexaString"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.HexaString.HexaString" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines a HexaString type.</p>
<p>The HexaString type describes a sequence of bytes of
arbitrary size with the hexastring notation (e.g. <code class="docutils literal notranslate"><span class="pre">b'aabbcc'</span></code>
instead of the raw notation <code class="docutils literal notranslate"><span class="pre">b'\xaa\xbb\xcc'</span></code>).</p>
<p>The HexaString constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, optional) – This parameter is used to describe a domain that contains a fixed hexastring. If None, the constructed hexastring will accept a random sequence of bytes, whose size may be specified (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBytes</span></code> parameter).</p></li>
<li><p><strong>nbBytes</strong> (an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a tuple with the min and the max sizes specified as <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains an amount of bytes. This amount can be fixed or represented with an interval. If None, the accepted sizes will range from 0 to 8192.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBytes</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The HexaString class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size in bits of the expected data type defined by a tuple (min, max).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p>The creation of a HexaString type with no parameter will create a bytes
object whose length ranges from 0 to 8192:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">533</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">7738</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">5505</span>
</pre></div>
</div>
<p>The following example shows how to define a hexastring object with
a constant value, and the use of the generation method to produce
a value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;aabbcc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xaa\xbb\xcc&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define a hexastring object with
a variable value, and the use of the generation method to produce
a value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">6</span>
</pre></div>
</div>
<p>It is not possible to define a hexastring that contains
semi-octets. However, it is possible to manually convert a
BitArray into a string that represents a semi-octet. This is
demonstrated in the following example where a 4-bit BitArray is
converted into the ‘a’ semi-octet.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="s1">&#39;1010&#39;</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()))[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">HexaString</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;aabb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xaa\xbb&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="string-type">
<h4>String Type<a class="headerlink" href="#string-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of an ASCII or Unicode type is made through the String class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.String.String">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">String</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbChars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/String.html#String"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.String.String" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines a String type, which is used to represent String
or Unicode characters.</p>
<p>The String type is a wrapper for the Python <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> object
with the capability to express more constraints on the permitted
string values.</p>
<p>The String constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – This parameter is used to describe a domain that contains a fixed string. If None, the constructed string will accept a random sequence of character, whose size may be specified (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbChars</span></code> parameter).</p></li>
<li><p><strong>nbChars</strong> (an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a tuple with the min and the max sizes specified as <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains an amount of characters. This amount can be fixed or represented with an interval. If None, the accepted sizes will range from 0 to 8192.</p></li>
<li><p><strong>encoding</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The encoding of the string, such as ‘ascii’ or
‘utf-8’. Default value is ‘utf-8’. Supported encodings are available on the Python reference documentation: <a class="reference external" href="https://docs.python.org/3.4/library/codecs.html#standard-encodings">Python Standard Encodings</a>.</p></li>
<li><p><strong>eos</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – A list defining the potential terminal characters for
the string. Default value is an empty list, meaning there
is no terminal character.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbChars</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The String class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size in bits of the expected data type defined by a tuple (min, max).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>encoding</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The encoding of the current value, such as ‘ascii’ or ‘utf-8’.</p></li>
<li><p><strong>eos</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list defining the potential terminal characters for
the string.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p>Strings can be either static, dynamic with fixed sizes or even
dynamic with variable sizes.</p>
<p>The creation of a String type with no parameter will create a string
object whose length ranges from 0 to 8192:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">String</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">533</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">2053</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">6908</span>
</pre></div>
</div>
<p>The following examples show how to define a static string in UTF-8:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;Paris&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;Paris&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;Paris in Euro: €&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;Paris in Euro: \xe2\x82\xac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;Paris in Euro: €&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;Paris in Euro: \xe2\x82\xac&#39;</span>
</pre></div>
</div>
<p>The following example shows the raising of an exception if input
value is not valid, with the definition of a string where
the associated value contains a non-String element:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;Paris in €&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Input value for the following string is incorrect: &#39;Paris in €&#39;...</span>
</pre></div>
</div>
<p>The following example shows how to define a string with a
fixed size and a dynamic content:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">10</span>
</pre></div>
</div>
<p>The following example shows how to define a string with a
variable size and a dynamic content:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">32</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>String with terminal character</strong></p>
<p>Strings with a terminal delimiter are supported. The following
example shows the usage of a delimiter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">eos</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Strings with a constant value and a terminal character are also supported.
The following example show the usage of this case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="n">eos</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;123&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abcdef123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">Field</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;abcdef123&#39;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">eos</span></code> attribute specifies a list of values that are used as
potential terminal characters. Terminal characters shall be
constant (such as <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> in the previous example).</p>
<p><strong>Using a default value</strong></p>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;A&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="bitarray-type">
<h4>BitArray Type<a class="headerlink" href="#bitarray-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of a bitfield type is made through the BitArray class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.BitArray.BitArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BitArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbBits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/BitArray.html#BitArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.BitArray.BitArray" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines a BitArray type.</p>
<p>The BitArray type describes an object that contains a
sequence of bits of arbitrary size.</p>
<p>The BitArray constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>, optional) – This parameter is used to describe a domain that contains a fixed array of bits. If None, the constructed BitArray will accept a random sequence of bits, whose size may be specified (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBits</span></code> parameter).</p></li>
<li><p><strong>nbBits</strong> (an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a tuple with the min and the max sizes specified as <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains an amount of bits. This amount can be fixed or represented with an interval. If None, the accepted sizes will range from 0 to 65535.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">nbBits</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The BitArray class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size in bits of the expected data type defined by a tuple (min, max).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>constants</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list of named constants used to access the
bitarray internal elements. Those elements are
automatically accessible by predefined named
constants, whose names can be changed. Besides,
elements can be accessed in read or write mode.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Important note about BitArray and 8-bit aligned data</strong></p>
<p>It is expected that BitArrays or successive BitArrays should
produce 8-bit aligned data. For example, if two successive
BitArrays are defined in a field, they should together produce
8-bit aligned data, as depicted below. In this example, an
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg"><code class="xref py py-class docutils literal notranslate"><span class="pre">Agg</span></code></a> is
used to concatenate two BitArrays in a <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain1</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain2</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Agg</span><span class="p">([</span><span class="n">domain1</span><span class="p">,</span> <span class="n">domain2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>If a field/symbol model contains BitArrays that does not
produce 8-bit aligned data, a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenerationException</span></code>
exception is raised during specialization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain1</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain2</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Agg</span><span class="p">([</span><span class="n">domain1</span><span class="p">,</span> <span class="n">domain2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.GenerationException</span>: <span class="n">specialize() produced 17 bits, which is not aligned on 8 bits. You should review the field model.</span>
</pre></div>
</div>
<p>However, no exception would be raised during data abstraction
in field/symbol, as the input data bytes are already 8-bit
aligned.</p>
</div>
<p>The creation of a BitArray type with no parameter will create a bytes
object whose length ranges from 0 to 65535:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">4962</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">7992</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">4529</span>
</pre></div>
</div>
<p>The following example shows how to define a BitArray
containing a fixed constant.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="s1">&#39;00001111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x0f&#39;</span>
</pre></div>
</div>
<p><strong>Bitarray of fixed and dynamic sizes</strong></p>
<p>The following example shows how to define a bitarray of 1 bit, 47
bits, 64 bits and then a bitarray with a variable size between 13
and 128 bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">47</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
<span class="go">47</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>
<span class="go">64</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">13</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">128</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Accessing bitarray elements by named constant</strong></p>
<p>In the following example, we define a bitarray with two
elements. As this bitarray has a fixed length, elements are
automatically accessible by predefined named constants (‘item_0’
and ‘item_1’):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="s1">&#39;00&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">constants</span>
<span class="go">[&#39;item_0&#39;, &#39;item_1&#39;]</span>
</pre></div>
</div>
<p>Bitarray element names can be changed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Urgent flag&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Data flag&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">constants</span>
<span class="go">[&#39;Urgent flag&#39;, &#39;Data flag&#39;]</span>
</pre></div>
</div>
<p>Bitarray elements can be accessed in read or write mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;Urgent flag&#39;</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;Urgent flag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;Urgent flag&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Bitarray elements can be used with binary operators:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;Urgent flag&#39;</span><span class="p">]</span> <span class="o">|=</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;Data flag&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;Urgent flag&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Using a default value</strong></p>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;1111111100000000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\xff\x00&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="ipv4-type">
<h4>IPv4 Type<a class="headerlink" href="#ipv4-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of an IPv4 type is made through the IPv4 class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.IPv4.IPv4">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IPv4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endianness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Endianness.BIG</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/IPv4.html#IPv4"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.IPv4.IPv4" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines an IPv4 type.</p>
<p>The IPv4 type encodes a <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> object in an IPv4
representation, and conversely decodes an IPv4 into a raw
object.</p>
<p>The IPv4 constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">netaddr.IPAddress</span></code>, optional) – This parameter is used to describe a domain that contains an IP value expressed in standard dot notation
(ex: “192.168.0.10”). The default value is None.</p></li>
<li><p><strong>network</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">netaddr.IPNetwork</span></code>, optional) – This parameter is used to describe a domain that contains a network address expressed in standard
dot notation (ex: “192.168.0.0/24”). The default value is None.</p></li>
<li><p><strong>endianness</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="netzob.Model.Vocabulary.Types.AbstractType.Endianness"><code class="xref py py-class docutils literal notranslate"><span class="pre">Endianness</span></code></a>, optional) – The endianness of the current value. Values must be Endianness.BIG or Endianness.LITTLE. The default value is Endianness.BIG.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">netaddr.IPAddress</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">network</span></code> parameters are mutually
exclusive. Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The IPv4 class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>network</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">netaddr.IPNetwork</span></code>) – A constraint over the network. The parsed data belongs to this network or not.</p></li>
<li><p><strong>endianness</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="netzob.Model.Vocabulary.Types.AbstractType.Endianness"><code class="xref py py-class docutils literal notranslate"><span class="pre">Endianness</span></code></a>) – The endianness of the value. Values must be Endianness.BIG or Endianness.LITTLE.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p>The creation of an IPv4 type with no parameter will create a random bytes
object of 4 bytes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">IPv4</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x93\tn|&#39;</span>
</pre></div>
</div>
<p>The following examples show the use of an IPv4 type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ip</span> <span class="o">=</span> <span class="n">IPv4</span><span class="p">(</span><span class="s2">&quot;192.168.0.10&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ip</span><span class="o">.</span><span class="n">value</span>
<span class="go">bitarray(&#39;11000000101010000000000000001010&#39;)</span>
</pre></div>
</div>
<p>It is also possible to specify an IPv4 type that accepts a range
of IP addresses, through the <code class="xref py py-attr docutils literal notranslate"><span class="pre">network</span></code> parameter, as shown in the
following example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ip</span> <span class="o">=</span> <span class="n">IPv4</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="s2">&quot;10.10.10.0/27&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IPv4</span><span class="p">(</span><span class="n">ip</span><span class="o">.</span><span class="n">generate</span><span class="p">())</span>  <span class="c1"># initialize with the generated bitarray value</span>
<span class="go">10.10.10.0</span>
</pre></div>
</div>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">IPv4</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x7f\x00\x00\x01&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="timestamp-type">
<h4>Timestamp Type<a class="headerlink" href="#timestamp-type" title="Permalink to this headline">#</a></h4>
<p>In the API, the definition of a timestamp type is done through the Timestamp class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Types.Timestamp.Timestamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Timestamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Epoch.UNIX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Unity.SECOND</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">UnitSize.SIZE_32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endianness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Endianness.BIG</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Sign.UNSIGNED</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Types/Timestamp.html#Timestamp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Types.Timestamp.Timestamp" title="Permalink to this definition">#</a></dt>
<dd><p>This class defines a Timestamp type.</p>
<p>The Timestamp type defines dates in a specific format
(such as Windows, Unix or MacOSX formats).</p>
<p>The Timestamp constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is used to describe a domain that contains a fixed timestamp (in seconds by default).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default generated value is the current time
in UTC.</p></li>
<li><p><strong>epoch</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Epoch</span></code>, optional) – <p>This parameter is the initial date expressed in UTC from which
timestamp is measured.</p>
<p>Available values for <cite>epoch</cite> parameter are:</p>
<ul>
<li><p>Epoch.WINDOWS = datetime(1601, 1, 1)</p></li>
<li><p>Epoch.MUMPS = datetime(1840, 12, 31)</p></li>
<li><p>Epoch.VMS = datetime(1858, 11, 17)</p></li>
<li><p>Epoch.EXCEL = datetime(1899, 12, 31)</p></li>
<li><p>Epoch.NTP = datetime(1900, 1, 1)</p></li>
<li><p>Epoch.MACOS_9 = datetime(1904, 1, 1)</p></li>
<li><p>Epoch.PICKOS = datetime(1967, 12, 31)</p></li>
<li><p>Epoch.UNIX = datetime(1970, 1, 1) (default epoch)</p></li>
<li><p>Epoch.FAT = datetime(1980, 1, 1)</p></li>
<li><p>Epoch.GPS = datetime(1980, 1, 6)</p></li>
<li><p>Epoch.ZIGBEE = datetime(2000, 1, 1)</p></li>
<li><p>Epoch.COCOA = datetime(2001, 1, 1)</p></li>
</ul>
</p></li>
<li><p><strong>unity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Unity</span></code>, optional) – <p>This specifies the unity of the value (seconds,
milliseconds, nanoseconds).</p>
<p>Available values for <cite>unity</cite> parameter are:</p>
<ul>
<li><p>Unity.SECOND = 1 (default unity)</p></li>
<li><p>Unity.DECISECOND = 10</p></li>
<li><p>Unity.CENTISECOND = 100</p></li>
<li><p>Unity.MILLISECOND = 1000</p></li>
<li><p>Unity.MICROSECOND = 1000000</p></li>
<li><p>Unity.NANOSECOND = 10000000000</p></li>
</ul>
</p></li>
<li><p><strong>unitSize</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize" title="netzob.Model.Vocabulary.Types.AbstractType.UnitSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitSize</span></code></a>, optional) – <p>The unitsize of the current value. Values must be one of
<code class="docutils literal notranslate"><span class="pre">UnitSize.SIZE_*</span></code>.</p>
<p>The following unit sizes are available:</p>
<ul>
<li><p>UnitSize.SIZE_32 (default unit size)</p></li>
<li><p>UnitSize.SIZE_64</p></li>
</ul>
</p></li>
<li><p><strong>endianness</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="netzob.Model.Vocabulary.Types.AbstractType.Endianness"><code class="xref py py-class docutils literal notranslate"><span class="pre">Endianness</span></code></a>, optional) – The endianness of the current value.
Values must be <code class="xref py py-attr docutils literal notranslate"><span class="pre">Endianness.BIG</span></code> or
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Endianness.LITTLE</span></code>.
The default value is <code class="xref py py-attr docutils literal notranslate"><span class="pre">Endianness.BIG</span></code>.</p></li>
<li><p><strong>sign</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign" title="netzob.Model.Vocabulary.Types.AbstractType.Sign"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sign</span></code></a>, optional) – The sign of the current value.
Values must be <code class="xref py py-attr docutils literal notranslate"><span class="pre">Sign.SIGNED</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">Sign.UNSIGNED</span></code>.
The default value is <code class="xref py py-attr docutils literal notranslate"><span class="pre">Sign.UNSIGNED</span></code>.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – This parameter is the default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code> parameters are mutually exclusive.
Setting both values raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</div>
<p>The Timestamp class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The current value of the instance. This value is represented
under the bitarray format.</p></li>
<li><p><strong>size</strong> (a tuple (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The size in bits of the expected data type defined by a tuple (min, max).
Instead of a tuple, an integer can be used to represent both min and max values.</p></li>
<li><p><strong>epoch</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Epoch</span></code>) – The initial date expressed in UTC from which
timestamp is measured.</p></li>
<li><p><strong>unity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Unity</span></code>) – This specifies the unity of the timestamp (seconds,
milliseconds, nanoseconds).</p></li>
<li><p><strong>unitSize</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.UnitSize" title="netzob.Model.Vocabulary.Types.AbstractType.UnitSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitSize</span></code></a>, optional) – The unitsize of the current value.</p></li>
<li><p><strong>sign</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Sign" title="netzob.Model.Vocabulary.Types.AbstractType.Sign"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sign</span></code></a>) – The sign of the current value.</p></li>
<li><p><strong>endianness</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.Endianness" title="netzob.Model.Vocabulary.Types.AbstractType.Endianness"><code class="xref py py-class docutils literal notranslate"><span class="pre">Endianness</span></code></a>) – The endianness of the current value.</p></li>
<li><p><strong>default</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>) – The default value used in specialization.</p></li>
</ul>
</dd>
</dl>
<p>The creation of a Timestamp type with no parameter will create a bytes
object of 4 bytes containing the current time in seconds from <code class="xref py py-attr docutils literal notranslate"><span class="pre">Epoch.UNIX</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<p>In the following example, a Timestamp data is created from a datetime
and represented as 32 bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">mktime</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">timetuple</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">time_timestamp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span><span class="o">.</span><span class="n">size</span>
<span class="go">(0, 4294967296)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span><span class="o">.</span><span class="n">value</span>
<span class="go">bitarray(&#39;01010110000110010101000010111010&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span><span class="o">.</span><span class="n">sign</span>
<span class="go">Sign.UNSIGNED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span><span class="o">.</span><span class="n">endianness</span>
<span class="go">Endianness.BIG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>
<span class="go">Sat Oct 10 17:54:02 2015</span>
</pre></div>
</div>
<p>This next example shows the usage of a default value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x04\xd2&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;00&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Start&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">(</span><span class="mi">1444737333</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Timestamp&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;00&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;End&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="n">RawMessage</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">Start | Timestamp     | End </span>
<span class="go">----- | ------------- | ----</span>
<span class="go">&#39;00&#39;  | b&#39;V\x1c\xf15&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | b&#39;V\x1c\xf15&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | b&#39;V\x1c\xf15&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | b&#39;V\x1c\xf15&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | b&#39;V\x1c\xf15&#39; | &#39;00&#39;</span>
<span class="go">----- | ------------- | ----</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">addEncodingFunction</span><span class="p">(</span><span class="n">TypeEncodingFunction</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">Start | Timestamp                  | End </span>
<span class="go">----- | -------------------------- | ----</span>
<span class="go">&#39;00&#39;  | &#39;Tue Oct 13 11:55:33 2015&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | &#39;Tue Oct 13 11:55:33 2015&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | &#39;Tue Oct 13 11:55:33 2015&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | &#39;Tue Oct 13 11:55:33 2015&#39; | &#39;00&#39;</span>
<span class="go">&#39;00&#39;  | &#39;Tue Oct 13 11:55:33 2015&#39; | &#39;00&#39;</span>
<span class="go">----- | -------------------------- | ----</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="modeling-fields">
<h2>Modeling Fields<a class="headerlink" href="#modeling-fields" title="Permalink to this headline">#</a></h2>
<p>In the API, field modeling is done through the Field class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Field'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isPseudoField</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Field.html#Field"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field" title="Permalink to this definition">#</a></dt>
<dd><p>The Field class is used in the definition of a Symbol structure.</p>
<p>A Field describes a chunk of a Symbol and is specified by a
definition domain, representing the set of values the field
accepts.</p>
<p>The Field constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>,
<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>,
or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, optional) – The definition domain of the field (i.e. the set of values
the field accepts). If not specified, the default definition
domain will be <code class="docutils literal notranslate"><span class="pre">Raw()</span></code>, meaning it accepts any values.
When this parameter is a list of fields, the constructor set
<code class="docutils literal notranslate"><span class="pre">self.fields=domain</span></code> and <code class="docutils literal notranslate"><span class="pre">self.domain=None</span></code>. Otherwise, it sets the <code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code> attribute. During this later operation, a normalization is done in order to convert the provided domain into a <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the field. If not specified, the
default name will be “Field”.</p></li>
<li><p><strong>isPseudoField</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag indicating if the field is a
pseudo field, meaning it is used
internally to help the computation
of the value of another field, but does
not directly produce data. The default value is False.</p></li>
</ul>
</dd>
</dl>
<p>The Field class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The definition domain of the field (i.e. the
set of values the field accepts). Only applicable when the current field has a definition domain. Setting this attribute will clean the list of sub-fields (i.e. the <code class="xref py py-attr docutils literal notranslate"><span class="pre">fields</span></code> attribute will be set to <code class="docutils literal notranslate"><span class="pre">[]</span></code>).
<code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">self.fields</span></code> is set.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the field.</p></li>
<li><p><strong>description</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The description of the field.</p></li>
<li><p><strong>fields</strong> (<em>list</em><em>[</em><a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><em>Field</em></a><em>]</em>) – The sorted list of sub-fields. Only applicable when the current field has sub-fields. Setting this attribute will clean the definition domain of the current field.</p></li>
<li><p><strong>parent</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><em>Field</em></a><em>,
</em><a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="netzob.Model.Vocabulary.Symbol.Symbol"><em>Symbol</em></a><em>]</em>) – The parent element.</p></li>
<li><p><strong>isPseudoField</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – A flag indicating if the field is a
pseudo field, meaning it is used
internally to help the computation
of the value of another field, but does
not directly produce data.</p></li>
</ul>
</dd>
</dl>
<p><strong>Fields hierarchy</strong></p>
<p>A field can be composed of sub-fields. This is useful for example
to separate a header, composed of multiple fields, from its
payload. The parent field can be seen as a facility to access
a group of fields.</p>
<p>In the following example, the <code class="docutils literal notranslate"><span class="pre">fheader</span></code> field is a parent field
for a group of sub-fields. The parent field does not contain any
concrete data, contrary to its sub-fields.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fh0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fh1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">fh0</span><span class="p">,</span> <span class="n">fh1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fheader&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>More generally, a field is part of a tree whose root is a symbol
and whose all other nodes are fields. Hence, a field
always has a parent which can be another field or a symbol if it
is the root.</p>
<p><strong>Field definition domain</strong></p>
<p>The value that can take a field is defined by its definition
domain. The definition domain of a field can take multiple forms,
in order to easily express basic types (such as Integer or String)
or to model complex data structures (such as alternatives,
repetitions or sequences).</p>
<p>The following examples present the different forms that make it possible to
express the same field content (i.e. an Integer with a constant
value of 10):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Data</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>If these fields are equivalent, this is because the first
parameter of the Field constructor is <code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code>, thus its
name can be omitted. Besides, the domain parameter will be parsed
by a factory, which accepts either the canonical form of a
definition domain (such as <cite>domain=Data(Integer(10))</cite>) or a
shortened form (such as <cite>domain=Integer(10)</cite>, or even
<cite>domain=10</cite>). In the later case, this means that it is possible to
use a Python native type that will be automatically converted to its equivalent in
Netzob type. Supported Python native types are <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> (converted in <a class="reference internal" href="#netzob.Model.Vocabulary.Types.Raw.Raw" title="netzob.Model.Vocabulary.Types.Raw.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">Raw</span></code></a>), <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> (converted in <a class="reference internal" href="#netzob.Model.Vocabulary.Types.String.String" title="netzob.Model.Vocabulary.Types.String.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>), <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> (converted in <a class="reference internal" href="#netzob.Model.Vocabulary.Types.Integer.Integer" title="netzob.Model.Vocabulary.Types.Integer.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>) and <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> (converted in <a class="reference internal" href="#netzob.Model.Vocabulary.Types.BitArray.BitArray" title="netzob.Model.Vocabulary.Types.BitArray.BitArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">BitArray</span></code></a>).</p>
<p>A domain may be composed of basic types, or complex data
structures. The following examples show how to express data
structures composed of 1) an alternative between the integers <cite>10</cite>
and <cite>20</cite>, 2) a repetition of the string <cite>a</cite>, and 3) an aggregate
(or concatenation) of the strings <cite>aa</cite> and <cite>bb</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Alt</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;aa&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]))</span>
</pre></div>
</div>
<p><strong>Relationships between fields</strong></p>
<p>A field can have its value related to the content of another
field. Such relationships may be specified through specific domain
objects, such as
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size"><code class="xref py py-class docutils literal notranslate"><span class="pre">Size</span></code></a> or
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a> classes.</p>
<p>The following example describes a size relationship with a String
field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="n">f0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Pseudo fields</strong></p>
<p>Sometimes, a specific field can be needed to express a complex
data structure that depends on external data. This is the purpose
of the <cite>isPseudoField</cite> flag. This flag indicates that the current
field is only used for the computation of the value of another
field, but does not produce real content during
specialization. The following example shows a pseudo field that
contains external data, and a real field whose content is the
size of the external data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_pseudo</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="s2">&quot;An external data&quot;</span><span class="p">,</span> <span class="n">isPseudoField</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_real</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Size</span><span class="p">(</span><span class="n">f_pseudo</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f_pseudo</span><span class="p">,</span> <span class="n">f_real</span><span class="p">])</span>
</pre></div>
</div>
<p>A real example of a pseudo field is found in the UDP checksum,
which relies on a pseudo IP header for its computation.</p>
<p><strong>Encoding functions applied to fields</strong></p>
<p>Encoding functions represent functions which apply to modify the
encoding of a data. The following example shows the use of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Base64EncodingFunction</span></code>
function to automatically decode base64 strings in the <cite>f1</cite> field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="s2">&quot;hello YWxs&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="s2">&quot;hello bXkgbG9yZA==&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span> <span class="o">=</span> <span class="s2">&quot;hello d29ybGQ=&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="n">RawMessage</span><span class="p">(</span><span class="n">m1</span><span class="p">),</span> <span class="n">RawMessage</span><span class="p">(</span><span class="n">m2</span><span class="p">),</span> <span class="n">RawMessage</span><span class="p">(</span><span class="n">m3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello &quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">messages</span><span class="o">=</span><span class="n">messages</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">f0       | f1            </span>
<span class="go">-------- | --------------</span>
<span class="go">&#39;hello &#39; | &#39;YWxs&#39;        </span>
<span class="go">&#39;hello &#39; | &#39;bXkgbG9yZA==&#39;</span>
<span class="go">&#39;hello &#39; | &#39;d29ybGQ=&#39;    </span>
<span class="go">-------- | --------------</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">addEncodingFunction</span><span class="p">(</span><span class="n">Base64EncodingFunction</span><span class="p">(</span><span class="n">encode_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">f0       | f1       </span>
<span class="go">-------- | ---------</span>
<span class="go">&#39;hello &#39; | &#39;all&#39;    </span>
<span class="go">&#39;hello &#39; | &#39;my lord&#39;</span>
<span class="go">&#39;hello &#39; | &#39;world&#39;  </span>
<span class="go">-------- | ---------</span>
</pre></div>
</div>
<p><strong>Field examples</strong></p>
<p>Here are examples of fields:</p>
<ul>
<li><p>a field containing the integer value 100</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>a field containing a specific binary: ‘1000’ = 8 in decimal</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="mb">0b1000</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>a field containing a raw value of 8 bits (1 byte)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>a field with a specific raw value</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x01\x02\x03</span><span class="s1">&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>a field representing a random IPv4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">IPv4</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li><p>a field representing a random String of 6 characters length:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>a field representing a random String with length between 5 and 20 characters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">payloadField</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
</pre></div>
</div>
</li>
<li><p>a field whose value is the size of the payloadField:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">Size</span><span class="p">(</span><span class="n">payloadField</span><span class="p">)])</span>
</pre></div>
</div>
</li>
<li><p>a field representing an alternative between two different strings, either “john” or “kurt”:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="s2">&quot;kurt&quot;</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p>a field representing a decimal (10) or a String of 16 chars:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">))])</span>
</pre></div>
</div>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Field.html#Field.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.str_structure">
<span class="sig-name descname"><span class="pre">str_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Field.html#Field.str_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.str_structure" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a string which denotes the current field definition
using a tree display.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The current field represented as a string.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">14</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Main field&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">str_structure</span><span class="p">())</span>
<span class="go">Main field</span>
<span class="go">|--  field1</span>
<span class="go">     |--   Data (String(nbChars=(0,8192)))</span>
<span class="go">|--  field2</span>
<span class="go">     |--   Data (Integer(10,100))</span>
<span class="go">|--  field3</span>
<span class="go">     |--   Data (Raw(nbBytes=14))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.abstract">
<span class="sig-name descname"><span class="pre">abstract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="netzob.Model.Vocabulary.Field.Field.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method is used to abstract the given
data bytes with the current symbol (or field) model. This method also works on fields, in order to abstract a <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> into a field object.</p>
<p>Similarly to the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.specialize" title="netzob.Model.Vocabulary.Field.Field.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method, it is possible to
indicate a Preset configuration that will be used to check
content parsed for specific fields. However, for the
<a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="netzob.Model.Vocabulary.Field.Field.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method, it is only possible to specify field
names for keys of the Preset configuration. The reason of this
restriction is that the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="netzob.Model.Vocabulary.Field.Field.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method returns an
<code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> containing also field names as keys.</p>
<p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="netzob.Model.Vocabulary.Field.Field.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, required) – The concrete message to abstract in symbol (or field).</p></li>
<li><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to check values in symbol (or field) structure obtained after message parsing.</p></li>
<li><p><strong>memory</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a>, optional) – A memory used to store variable values during
specialization and abstraction of sequence of symbols (or fields).
The default value is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The structure of the parsed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> where keys are <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> and values are <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractionException</span></code> if an error occurs while abstracting the data</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.abstract" title="netzob.Model.Vocabulary.Field.Field.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method, it is
important to explicitly name all the fields with different
names, because the resulting OrderedDict will use field
names as its keys.</p>
</div>
<p><strong>Abstracting data into a field</strong></p>
<p>The following code shows an example of abstracting a data
according to a field definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;john, what&#39;s up in </span><span class="si">{}</span><span class="s2"> ?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="s1">&#39;Berlin&#39;</span><span class="p">]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1a</span><span class="p">,</span> <span class="n">f2a</span><span class="p">,</span> <span class="n">f3a</span><span class="p">,</span> <span class="n">f4a</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">structured_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">structured_data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Berlin&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
<p><strong>Abstracting data into a symbol</strong></p>
<p>The following code shows an example of abstracting a data
according to a symbol definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;john, what&#39;s up in </span><span class="si">{}</span><span class="s2"> ?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="s1">&#39;Berlin&#39;</span><span class="p">]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1a</span><span class="p">,</span> <span class="n">f2a</span><span class="p">,</span> <span class="n">f3a</span><span class="p">,</span> <span class="n">f4a</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Symbol-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">structured_data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">structured_data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Berlin&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
<p><strong>Usage of Symbol for traffic generation and parsing</strong></p>
<p>A Symbol class may be used to generate concrete messages according
to its field definition, through the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> method, and
may also be used to abstract a concrete message into its
associated symbol through the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;aaaa&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot; # &quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;bbbbbb&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">concrete_message</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">concrete_message</span>
<span class="go">b&#39;aaaa # bbbbbb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">concrete_message</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;aaaa&#39;), (&#39;f1&#39;, b&#39; # &#39;), (&#39;f2&#39;, b&#39;bbbbbb&#39;)])</span>
</pre></div>
</div>
<p><strong>Usage of Preset during message abstraction</strong></p>
<p>The following code shows an example of abstracting a data
according to a symbol definition and a defined Preset configuration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Symbol-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We build a Preset configuration indicating that we expect &quot;Paris&quot; for the field f3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Paris&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john, what&#39;s up in Berlin ?&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;Symbol-john&#39;, can abstract the data: &#39;john, what&#39;s up in Berlin ?&#39;, but some parsed values do not match the expected preset.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john, what&#39;s up in Paris ?&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Field.html#Field.count"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.count" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.count" title="netzob.Model.Vocabulary.Field.Field.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> method computes the expected number of unique
messages produced, considering the initial field model and the
preset configuration.</p>
<p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.count" title="netzob.Model.Vocabulary.Field.Field.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> method expects the following parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables. This configuration will impact the expected number of unique messages the field would produce.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The number of unique values the field specialization can produce.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The theoretical value returned by <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.count" title="netzob.Model.Vocabulary.Field.Field.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>
may be huge. Therefore, we force the returned value to be
<code class="xref py py-attr docutils literal notranslate"><span class="pre">MAXIMUM_POSSIBLE_VALUES</span></code> (86400000000), if the
theoretical result is beyond this threshold. This limit
corresponds to 1 day of data generation based on a generation
bandwith of 1 million per second.</p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Field definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.Fuzzing.Generators.DeterministGenerator</span> <span class="kn">import</span> <span class="n">DeterministGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint16</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Count the expected number of unique produced messages</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>  <span class="c1">#  Here, the following computation is done: 951*256*256 (f1 is able to produce 1000-50+1=951 possible values, based on its interval)</span>
<span class="go">62324736</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify a preset configuration for field &#39;f2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>  <span class="c1"># Here, the following computation is done: 951*1*256 (as the f2 field value is set to 42, f2 can now produce only 1 possible value)</span>
<span class="go">243456</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify a preset configuration for field &#39;f3&#39; by activating fuzzing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(</span><span class="n">f3</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="s1">&#39;determinist&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>  <span class="c1"># Here, the following computation is done: 951*1*29 (29 corresponds to the number of possible values generated by the determinist generator)</span>
<span class="go">27579</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.getField">
<span class="sig-name descname"><span class="pre">getField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.getField" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve a sub-field based on its name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, required) – the name of the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The sub-field object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>KeyError</strong> – when the field has not been found</p>
</dd>
</dl>
<p>The following example shows how to retrieve a sub-field based
on its name:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;fheader&quot;</span><span class="p">)</span>  <span class="c1"># create a Field named &#39;fheader&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">]</span> <span class="c1"># this Field is parent of 3 existing Fields</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">fheader</span><span class="o">.</span><span class="n">getField</span><span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">))</span> <span class="c1"># get the sub-field named &#39;f2&#39;</span>
<span class="go">&lt;class &#39;netzob.Model.Vocabulary.Field.Field&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getField</span><span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">))</span> <span class="c1"># get the field named &#39;f2&#39; in the symbol</span>
<span class="go">&lt;class &#39;netzob.Model.Vocabulary.Field.Field&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.getSymbol">
<span class="sig-name descname"><span class="pre">getSymbol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.getSymbol" title="Permalink to this definition">#</a></dt>
<dd><p>Return the symbol to which this field is attached.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The associated symbol if available.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="netzob.Model.Vocabulary.Symbol.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NoSymbolException</span></code></p>
</dd>
</dl>
<p>To retrieve the associated symbol, this method recursively
calls the parent of the current object until the root is found.</p>
<p>If the root is not a <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="netzob.Model.Vocabulary.Symbol.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a>, this raises an Exception.</p>
<p>The following example shows how to retrieve the parent symbol
from a field object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">field</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span><span class="o">.</span><span class="n">getSymbol</span><span class="p">()</span>
<span class="go">S0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">getSymbol</span><span class="p">())</span>
<span class="go">&lt;class &#39;netzob.Model.Vocabulary.Symbol.Symbol&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Field.Field.specialize">
<span class="sig-name descname"><span class="pre">specialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Iterator</span><span class="p"><span class="pre">[</span></span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Field.html#Field.specialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Field.Field.specialize" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.specialize" title="netzob.Model.Vocabulary.Field.Field.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method is intended to produce concrete
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> data based on the field model. This method
returns a Python generator that in turn provides data
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> object at each call to <code class="docutils literal notranslate"><span class="pre">next(generator)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables.</p></li>
<li><p><strong>memory</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a>, optional) – A memory used to store variable values during
specialization and abstraction of successive
fields, especially to handle inter-symbol
relationships. If None, a temporary memory is
created by default and used internally during the scope of the
specialization process.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A generator that provides data <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> at each call to <code class="docutils literal notranslate"><span class="pre">next(generator)</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator[bytes]</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerationException</span></code> if an error occurs while specializing the field.</p>
</dd>
</dl>
<p>The following example shows the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.specialize" title="netzob.Model.Vocabulary.Field.Field.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method used for a
field which contains a string with a constant value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;hello&#39;</span>
</pre></div>
</div>
<p>The following example shows the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field.specialize" title="netzob.Model.Vocabulary.Field.Field.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method used for a
field which contains a string with a variable value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="modeling-variables">
<h2>Modeling Variables<a class="headerlink" href="#modeling-variables" title="Permalink to this headline">#</a></h2>
<p>The definition domain of a field is represented by a tree of variables, containing leaf and node variables. Each variable follows a common API, which is described in the abstract class AbstractVariable:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AbstractVariable</span></span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/AbstractVariable.html#AbstractVariable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="Permalink to this definition">#</a></dt>
<dd><p>A variable participates in the definition domain of a field.</p>
<p>The AbstractVariable class defines the API of a variable, which can be a leaf or a node variable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable.copy">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/AbstractVariable.html#AbstractVariable.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Clone the current object as well as all its dependencies. This
method returns a new object of the same type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable.isnode">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isnode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/AbstractVariable.html#AbstractVariable.isnode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable.isnode" title="Permalink to this definition">#</a></dt>
<dd><p>Tells if the current variable is a node variable, which means it as children.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the current variable is a node variable.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="modeling-data-variables">
<h2>Modeling Data Variables<a class="headerlink" href="#modeling-data-variables" title="Permalink to this headline">#</a></h2>
<p>In the API, data variable modeling is made through the class Data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Data.html#Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data" title="Permalink to this definition">#</a></dt>
<dd><p>The Data class is a variable which embeds specific content.</p>
<p>A Data object stores the definition domain of a variable and the constraints
over it, through a <code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code> object.</p>
<p>The Data constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataType</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>, required) – The type of the data (for example Integer,
Raw, String, …).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the data (if None, the name will
be generated).</p></li>
<li><p><strong>scope</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Scope.Scope" title="netzob.Model.Vocabulary.Domain.Variables.Scope.Scope"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scope</span></code></a>, optional) – The Scope strategy defining how the Data value is
used during the abstraction and specialization process.
The default strategy is <code class="docutils literal notranslate"><span class="pre">Scope.NONE</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>The Data class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataType</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>) – The type of the data.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the variable (Read-only).</p></li>
</ul>
</dd>
</dl>
<p>The following example shows the definition of the Data <cite>pseudo</cite>
with a String type and a <cite>“hello”</cite> default value. This means that
this Data object accepts any string, and the default generated value
of this object is <cite>“hello”</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">dataType</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pseudo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
<span class="go">String(nbChars=5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;pseudo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;hello&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Data.html#Data.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Data.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="modeling-node-variables">
<h2>Modeling Node Variables<a class="headerlink" href="#modeling-node-variables" title="Permalink to this headline">#</a></h2>
<p>Multiple variables can be combined to form a complex and precise
specification of the values that are accepted by a field. Four complex
variable types are provided:</p>
<ul class="simple">
<li><p><strong>Aggregate node variables</strong>, which can be used to model a concatenation of variables.</p></li>
<li><p><strong>Alternate node variables</strong>, which can be used to model an alternative of multiple variables.</p></li>
<li><p><strong>Repeat node variables</strong>, which can be used to model a repetition of a variable.</p></li>
<li><p><strong>Optional node variables</strong>, which can be used to model a variable
that may or may not be present.</p></li>
</ul>
<p>Those node variables are described in detail in this chapter.</p>
<section id="aggregate-domain">
<h3>Aggregate Domain<a class="headerlink" href="#aggregate-domain" title="Permalink to this headline">#</a></h3>
<p>In the API, the definition of a concatenation of variables is made through the Agg class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Agg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_optional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Agg.html#Agg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg" title="Permalink to this definition">#</a></dt>
<dd><p>The Agg class is a node variable that represents a concatenation of variables.</p>
<p>An aggregate node concatenates the values that are accepted by
its children nodes. It can be used to specify a succession of
tokens.</p>
<p>The Agg constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>children</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, optional) – The sequence of variable elements contained in
the aggregate. The default value is None.</p></li>
<li><p><strong>last_optional</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – A flag indicating if the last element of the children is optional or not. The default value is False.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable (if None, the name will
be generated).</p></li>
</ul>
</dd>
</dl>
<p>The Agg class supports modeling of direct recursions on the
right. To do so, the flag <code class="docutils literal notranslate"><span class="pre">SELF</span></code> is available, and should only
be used in the last position of the aggregate (see example below).</p>
<p>The Agg class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>children</strong> (a list of <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The sorted typed list of children attached to the variable node.</p>
</dd>
</dl>
<p><strong>Aggregate examples</strong></p>
<p>For example, the following code represents a field that
accepts values that are made of a String of 3 to 20 random
characters followed by a “.txt” extension:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">]))</span>
</pre></div>
</div>
<p>The following example shows an aggregate between BitArray
variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="n">BitArray</span><span class="p">(</span><span class="s1">&#39;01101001&#39;</span><span class="p">),</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">BitArray</span><span class="p">(</span><span class="n">nbBits</span><span class="o">=</span><span class="mi">5</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p><strong>Examples of Agg internal attribute access</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">Raw</span><span class="p">(),</span> <span class="n">String</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
<span class="go">Raw(nbBytes=(0,8192))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
<span class="go">String(nbChars=(0,8192))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p><strong>Abstraction of aggregate variables</strong></p>
<p>This example shows the abstraction process of an Aggregate
variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john.txt!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;john.txt&#39;), (&#39;f1&#39;, b&#39;!&#39;)])</span>
</pre></div>
</div>
<p>In the following example, an Aggregate variable is defined. A
message that does not correspond to the expected model is then
parsed, thus an exception is returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;johntxt!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;Field&#39;, cannot abstract the data: &#39;johntxt!&#39;. Error: &#39;No parsing path returned while parsing &#39;b&#39;johntxt!&#39;&#39;&#39;</span>
</pre></div>
</div>
<p><strong>Specialization of aggregate variables</strong></p>
<p>This example shows the specialization process of an Aggregate
variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot; john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Agg</span><span class="p">([</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;hello john&#39;</span>
</pre></div>
</div>
<p><strong>Optional last variable</strong></p>
<p>This example shows the specialization and parsing of an aggregate
with an optional last variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">int8</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">int8</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">res</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02\x03</span><span class="s1">&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02\x03</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;Field&#39;, b&#39;\x02\x03&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;Field&#39;, b&#39;\x02&#39;)])</span>
</pre></div>
</div>
<p><strong>Modeling indirect imbrication</strong></p>
<p>The following example shows how to specify a field with a
structure (<code class="docutils literal notranslate"><span class="pre">v2</span></code>) that can contain another structure (<code class="docutils literal notranslate"><span class="pre">v0</span></code>),
through a tierce structure (<code class="docutils literal notranslate"><span class="pre">v1</span></code>). The flag <code class="docutils literal notranslate"><span class="pre">last_optional</span></code> is
used to indicate that the specialization or parsing of the last
element of the aggregates <code class="docutils literal notranslate"><span class="pre">v1</span></code> and <code class="docutils literal notranslate"><span class="pre">v2</span></code> is optional.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="n">int8</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="n">int8</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">v0</span><span class="p">],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">int8</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">v1</span><span class="p">],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test specialization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">res</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">!</span><span class="se">\x03</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">res</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">!</span><span class="se">\x03</span><span class="s1">?</span><span class="se">\x04</span><span class="s1">&#39;</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test parsing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;Field&#39;, b&#39;\x02&#39;)])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Important note about recursion</strong></p>
<p>The library can handle both direct and indirect recursion. However,
there is a limitation requiring the use of a recursing variable on the
<strong>right side of a statement</strong>. Any other behavior could lead to
infinite recursion during the loading of the model.
To help understand what syntax should be preferred, here is a list of
annotated BNF syntaxes.</p>
<p><em>invalid syntaxes:</em></p>
<pre>
<strong id="grammar-token-A"><span id="grammar-token-a"></span>A</strong> ::=  [A] integer
       &lt;recursion on the left side&gt;
<strong id="grammar-token-B"><span id="grammar-token-b"></span>B</strong> ::=  ( &quot;(&quot; B ) | ( &quot;.&quot; &quot;)&quot; )
       &lt;recursion on the middle&gt;
</pre>
<p><em>valid adaptations from above examples</em>:</p>
<pre>
<strong id="grammar-token--0">A </strong> ::=  integer+
        &lt;recursion is replaced by a repeat approach&gt;
<strong id="grammar-token--1">B </strong> ::=  B' &quot;)&quot;
        &lt;split the statement ...&gt;
<strong id="grammar-token--2">B'</strong> ::=  ( &quot;(&quot; B ) | &quot;.&quot;
        &lt;direct recursion converted in an indirect one
        on the right&gt;
</pre>
<p><em>valid recursion examples</em>:</p>
<pre>
<strong id="grammar-token-C"><span id="grammar-token-c"></span>C</strong> ::=  &quot;.&quot; C*
        &lt;a string with one or more dot characters&gt;
<strong id="grammar-token-D"><span id="grammar-token-d"></span>D</strong> ::=  ( D | &quot;.&quot; )*
        &lt;a string with zero or more dot characters&gt;
</pre>
</div>
<p><strong>Modeling direct recursion, simple example</strong></p>
<p>The following example shows how to specify a field with a
structure (<code class="docutils literal notranslate"><span class="pre">v</span></code>) that can optionally contain itself. To model
such recursive structure, the <code class="docutils literal notranslate"><span class="pre">SELF</span></code> flag has to be used in the
last position of the aggregate.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">int8</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">SELF</span><span class="p">],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test specialization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>  
<span class="go">b&#39;\x02\x04\x01&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test parsing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> 
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Modeling direct recursion, more complex example</strong></p>
<p>This example introduces a recursion in the middle of an expression by
modeling a pair group of parentheses (<code class="docutils literal notranslate"><span class="pre">'('</span></code> and <code class="docutils literal notranslate"><span class="pre">')'</span></code>), around a
single character (<code class="docutils literal notranslate"><span class="pre">'+'</span></code>).
The BNF syntax of this model would be:</p>
<pre>
<strong id="grammar-token-parentheses">parentheses</strong> ::=  ( &quot;(&quot; parentheses )  | ( &quot;+&quot;  &quot;)&quot; )
</pre>
<p>This syntax introduces a recursivity in the middle of the <cite>left</cite> statement,
which <strong>is not supported</strong>. Instead, this syntax could be adapted to move
the recursivity to the right.</p>
<pre>
<strong id="grammar-token--3">parentheses</strong> ::=  left right
<strong id="grammar-token-left">left       </strong> ::=  ( &quot;(&quot; parentheses ) | &quot;+&quot;
<strong id="grammar-token-right">right      </strong> ::=  &quot;)&quot;
</pre>
<p>The following models describe this issue and provide a workaround.</p>
<p><strong>BAD way</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parentheses</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">Alt</span><span class="p">([</span><span class="n">SELF</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">]),</span> <span class="s2">&quot;)&quot;</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ValueError</span>: <span class="n">SELF can only be set at the last position of an Agg</span>
</pre></div>
</div>
<p><strong>GOOD way</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parentheses</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">Alt</span><span class="p">([</span><span class="n">parentheses</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">right</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parentheses</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">Field</span><span class="p">(</span><span class="n">parentheses</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;((+))&#39;</span>
</pre></div>
</div>
<p><strong>Modeling indirect recursion, simple example</strong></p>
<p>The following example shows how to specify a field with a
structure (<code class="docutils literal notranslate"><span class="pre">v2</span></code>) that contains another structure (<code class="docutils literal notranslate"><span class="pre">v1</span></code>), which
can itself contain the first structure (<code class="docutils literal notranslate"><span class="pre">v2</span></code>). The flag
<code class="docutils literal notranslate"><span class="pre">last_optional</span></code> is used to indicate that the specialization or
parsing of the last element of the aggregate <code class="docutils literal notranslate"><span class="pre">v2</span></code> is optional.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">int8</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">v1</span><span class="p">],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>  
<span class="go">b&#39;\x03!\x03!\x03!\x03&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test parsing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  
<span class="go">OrderedDict([(&#39;Field&#39;, b&#39;\x01!\x01&#39;)])</span>
</pre></div>
</div>
<p><strong>Modeling indirect recursion, more complex example</strong></p>
<p>The following syntax provides a way to parse and specialize a subset of
mathematical expressions including pair group of parentheses, digits from 0
to 9 and two arithmetic operators (‘+’ and ‘*’).</p>
<pre>
<strong id="grammar-token-num">num      </strong> ::=  &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
<strong id="grammar-token-operator">operator </strong> ::=  &quot;+&quot; | &quot;*&quot;
<strong id="grammar-token-operation">operation</strong> ::=  left [right]
<strong id="grammar-token--4">left     </strong> ::=  num | subop
<strong id="grammar-token--5">right    </strong> ::=  operator operation
<strong id="grammar-token-subop">subop    </strong> ::=  &quot;(&quot; operation &quot;)&quot;
</pre>
<p>The following examples <strong>should</strong> be compatible with these expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="mi">5</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>
</pre></div>
</div>
<p>These last expressions <strong>should not</strong> be compatible with these expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">1</span> <span class="o">**</span> <span class="mi">2</span>
<span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">*</span>
</pre></div>
</div>
<p>This example of indirect recursion introduces a recursion of the
<cite>operation</cite> statement, called in the <cite>subop</cite> statement.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num</span> <span class="o">=</span> <span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operator</span> <span class="o">=</span> <span class="n">Alt</span><span class="p">([</span><span class="s2">&quot; + &quot;</span><span class="p">,</span> <span class="s2">&quot; * &quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operation</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([],</span> <span class="n">last_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subop</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">left</span> <span class="o">=</span> <span class="n">Alt</span><span class="p">([</span><span class="n">num</span><span class="p">,</span> <span class="n">subop</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">right</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">operator</span><span class="p">,</span> <span class="n">operation</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">operation</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">Field</span><span class="p">(</span><span class="n">operation</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>  
<span class="go">b&#39;((((4 * 8 * 4) + 5 + 9 + 0) * 7 * 0 + (4 + 9 + (3 * 4 + 2) * 0) * 9) + 4 * 7)&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Agg.html#Agg.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Agg.Agg"><code class="xref py py-class docutils literal notranslate"><span class="pre">Agg</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="alternate-domain">
<h3>Alternate Domain<a class="headerlink" href="#alternate-domain" title="Permalink to this headline">#</a></h3>
<p>In the API, the definition of an alternate of variables is made through the Alt class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Alt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Alt.html#Alt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt" title="Permalink to this definition">#</a></dt>
<dd><p>The Alt class is a node variable that represents an alternative of variables.</p>
<p>A definition domain can take the form of a combination of
permitted values/types/domains. This combination is represented by
an alternate node. It can be seen as an OR operator between two or
more children nodes.</p>
<p>The Alt constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>children</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, optional) – The set of variable elements permitted in the
alternative. The default is None.</p></li>
<li><p><strong>callback</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>, optional) – The callback function that may be used to determine the child index to select. The default is None.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable (if None, the name will
be generated).</p></li>
</ul>
</dd>
</dl>
<p>The Alt class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>children</strong> (a list of <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The sorted typed list of children attached to the variable node.</p></li>
<li><p><strong>callback</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>) – The callback function that may be used to determine the child index to select.</p></li>
</ul>
</dd>
</dl>
<p><strong>Callback prototype</strong></p>
<p>The callback function that can be used to determine the child
index to select has the following prototype:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">cbk_child_selection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>object</em>) – data structure that allows access to the values of the
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>
elements.</p></li>
<li><p><strong>children</strong> (<em>List</em><em>[</em><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt"><em>Alt</em></a><em>]</em>) – children of the
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alt</span></code></a>
variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The callback function should return an integer used to determine
the child index to select.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">children</span></code> is a list of <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>. Each
<code class="docutils literal notranslate"><span class="pre">child</span></code> can have children if it is a node. Access to child
values, as well as to its own children values, is done through the
<code class="docutils literal notranslate"><span class="pre">path</span></code> data structure, thanks to its methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">hasData()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">getData()</span></code>. Those
methods therefore allow access to a hierarchy of elements for
which the <code class="docutils literal notranslate"><span class="pre">child</span></code> is the root element:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">path.hasData(element)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code> telling if a data has
been specialized or parsed for the element
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">path.getData(element)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> that corresponds
to the value specialized or parsed for the element
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
</ul>
<p>It is possible to test if a <code class="docutils literal notranslate"><span class="pre">child</span></code> variable is a node
of the tree structure through the <code class="docutils literal notranslate"><span class="pre">isnode(child)</span></code> method. A
node may represent an <code class="docutils literal notranslate"><span class="pre">Agg</span></code>, an <code class="docutils literal notranslate"><span class="pre">Alt</span></code>, a <code class="docutils literal notranslate"><span class="pre">Repeat</span></code> or an
<code class="docutils literal notranslate"><span class="pre">Opt</span></code> variable. Access to the node leafs is possible with the
attribute <code class="docutils literal notranslate"><span class="pre">children</span></code> (i.e. <code class="docutils literal notranslate"><span class="pre">child.children</span></code>). The type of the
children leafs is also <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p>
<p><strong>Alt examples</strong></p>
<p>The following code denotes an alternate object that
accepts either the string “filename1.txt” or the string
“filename2.txt”:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;filename1.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;filename2.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span> <span class="o">=</span> <span class="n">Alt</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Examples of Alt internal attribute access</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span> <span class="o">=</span> <span class="n">Alt</span><span class="p">([</span><span class="n">Raw</span><span class="p">(),</span> <span class="n">String</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
<span class="go">Raw(nbBytes=(0,8192))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
<span class="go">String(nbChars=(0,8192))</span>
</pre></div>
</div>
<p><strong>Example of a deterministic Alt computation</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cbk</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Alt</span><span class="p">([</span><span class="n">String</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="s2">&quot;abc&quot;</span><span class="p">],</span> <span class="n">callback</span><span class="o">=</span><span class="n">cbk</span><span class="p">),</span> <span class="s2">&quot;alt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">b&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;alt&#39;, b&#39;c&#39;)])</span>
</pre></div>
</div>
<p><strong>Abstraction of alternate variables</strong></p>
<p>This example shows the abstraction process of an Alternate
variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;kurt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Alt</span><span class="p">([</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;kurt&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;kurt&#39;)])</span>
</pre></div>
</div>
<p>In the following example, an Alternate variable is defined. A
message that does not correspond to the expected model is then
parsed, thus an exception is returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;nothing&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;Symbol&#39;, cannot abstract the data: &#39;nothing&#39;. Error: &#39;No parsing path returned while parsing &#39;b&#39;nothing&#39;&#39;&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Alt.html#Alt.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Alt.Alt"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alt</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="repeat-domain">
<h3>Repeat Domain<a class="headerlink" href="#repeat-domain" title="Permalink to this headline">#</a></h3>
<p>In the API, the definition of a repetition of variables, or sequence, is made through the Repeat class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbRepeat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Repeat.html#Repeat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat" title="Permalink to this definition">#</a></dt>
<dd><p>The Repeat class is a node variable that represents a sequence of
the same variable. This denotes an n-time repetition of a
variable, which can be a terminal leaf or a non-terminal node.</p>
<p>The Repeat constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>child</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The variable element that will be repeated.</p></li>
<li><p><strong>nbRepeat</strong> (an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or
a Python variable containing an <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or a
<a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> or a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>, required) – The number of repetitions of the element. This value can be a fixed integer, a tuple of integers defining the minimum and maximum of permitted repetitions, a constant from the calling script, a value present in another field, or can be identified by calling a callback function. In the latter case, the callback function should return a boolean telling if the expected number of repetitions is reached. Those use cases are described below.</p></li>
<li><p><strong>delimiter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>, optional) – The delimiter used to separate the repeated element. The default is None.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable (if None, the name will
be generated).</p></li>
</ul>
</dd>
</dl>
<p>The Repeat class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>children</strong> (a list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code>) – The list of one element which is the child attached to the variable node.</p>
</dd>
</dl>
<p><strong>Callback prototype</strong></p>
<p>The callback function that can be used in the <code class="docutils literal notranslate"><span class="pre">nbRepeat</span></code>
parameter has the following prototype:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">cbk_nbRepeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb_repeat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remaining</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nb_repeat</strong> (<em>int</em>) – the number of times the child element has been parsed
or specialized.</p></li>
<li><p><strong>data</strong> (<em>bitarray</em>) – the already parsed or specialized data.</p></li>
<li><p><strong>path</strong> (<em>object</em>) – data structure that allows access to the values of the
parsed <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>
elements.</p></li>
<li><p><strong>child</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – the repeated element.</p></li>
<li><p><strong>remaining</strong> (<em>bitarray</em>) – the remaining data to be parsed.
Only set in parsing mode. In specialization mode, this
parameter will have a <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> value. This parameter can
therefore be used to identify the current mode.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>The callback function should return one of the following values:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">RepeatResult.CONTINUE</span></code>: this tells to continue the repetition.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">RepeatResult.STOP_BEFORE</span></code>: this tells to stop the repetition before the current value of the child.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">RepeatResult.STOP_AFTER</span></code>: this tells to stop the repetition after the current value of the child.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">child</span></code> is a <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>. The
<code class="docutils literal notranslate"><span class="pre">child</span></code> can have children if it is a node. Access to child
values, as well as to its own children values, is done through the
<code class="docutils literal notranslate"><span class="pre">path</span></code> data structure, thanks to its methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">hasData()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">getData()</span></code>. Those
methods therefore allow access to a hierarchy of elements for
which the <code class="docutils literal notranslate"><span class="pre">child</span></code> is the root element:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">path.hasData(element)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code> telling if a data has
been specialized or parsed for the element
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">path.getData(element)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> that corresponds
to the value specialized or parsed for the element
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
</ul>
<p>It is possible to test if a <code class="docutils literal notranslate"><span class="pre">child</span></code> variable is a node
of the tree structure through the <code class="docutils literal notranslate"><span class="pre">isnode(child)</span></code> method. A
node may represent an <code class="docutils literal notranslate"><span class="pre">Agg</span></code>, an <code class="docutils literal notranslate"><span class="pre">Alt</span></code>, a <code class="docutils literal notranslate"><span class="pre">Repeat</span></code> or an
<code class="docutils literal notranslate"><span class="pre">Opt</span></code> variable. Access to the node leafs is possible with the
attribute <code class="docutils literal notranslate"><span class="pre">children</span></code> (i.e. <code class="docutils literal notranslate"><span class="pre">child.children</span></code>). The type of the
children leafs is also <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p>
<p>The callback function is called each time the child element is
seen.</p>
<p><strong>Basic usage of Repeat</strong></p>
<p>The following example shows a repeat variable where the repeated
element is a String:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;AAAAAAAAAAAAAAAA&#39;</span>
</pre></div>
</div>
<p><strong>Limiting the number of repetitions with an integer</strong></p>
<p>The following example shows how to create a Repeat variable whose
number of repetitions is limited by an integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Limiting the number of repetitions with an interval of integers</strong></p>
<p>The following example shows how to create a Repeat variable whose
number of repetitions is limited by an interval of integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<p><strong>Limiting the number of repetitions with a Python integer variable</strong></p>
<p>The following example shows how to create a Repeat variable whose
number of repetitions is limited by a Python integer
variable. Such a variable is typically managed by the calling script:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="n">var</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Usage of a delimiter in Repeat</strong></p>
<p>We can specify a delimiter between each repeated element, as
depicted in the following example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">Alt</span><span class="p">([</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)]),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">... </span>          <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;B-A-A&#39;</span>
</pre></div>
</div>
<p><strong>Limiting the number of repetitions with the value of another field</strong></p>
<p>The following example shows how to create a Repeat variable whose
number of repetitions is limited by the value of another field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_nb</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_pattern</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="n">f_nb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_header</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f_nb</span><span class="p">,</span> <span class="n">f_pattern</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f_header</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;\x00\x05johnjohnjohnjohnjohn&#39;</span>
</pre></div>
</div>
<p><strong>Limiting the number of repetitions by calling a callback function</strong></p>
<p>The following example shows how to create a Repeat variable whose
number of repetitions is handled by calling a callback function
telling if the expected number of repetitions is reached. Here, in
parsing mode, the repeat stops when the <cite>b’B’</cite> byte is
encountered. In specialization mode, the repeat stops at the first
iteration.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cbk</span><span class="p">(</span><span class="n">nb_repeat</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">remaining</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># This means we are in parsing mode</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in cbk: nb_repeat:</span><span class="si">{}</span><span class="s2"> -- data:</span><span class="si">{}</span><span class="s2"> -- remaining:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_repeat</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(),</span> <span class="n">remaining</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()))</span>
<span class="gp">...</span>
<span class="gp">... </span>        <span class="c1"># We check the value of the second child of the parameter child</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">isnode</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">second_subchild</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">hasData</span><span class="p">(</span><span class="n">second_subchild</span><span class="p">)</span> <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="n">second_subchild</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;B&#39;</span><span class="p">:</span>
<span class="gp">... </span>                <span class="k">return</span> <span class="n">RepeatResult</span><span class="o">.</span><span class="n">STOP_BEFORE</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">RepeatResult</span><span class="o">.</span><span class="n">CONTINUE</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">RepeatResult</span><span class="o">.</span><span class="n">STOP_AFTER</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">Alt</span><span class="p">([</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)]),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="n">cbk</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;ABC&#39;</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;BBC&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;AABC&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">in cbk: nb_repeat:1 -- data:b&#39;A&#39; -- remaining:b&#39;ABC&#39;</span>
<span class="go">in cbk: nb_repeat:2 -- data:b&#39;AA&#39; -- remaining:b&#39;BC&#39;</span>
<span class="go">in cbk: nb_repeat:3 -- data:b&#39;AAB&#39; -- remaining:b&#39;C&#39;</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;AA&#39;), (&#39;f2&#39;, b&#39;B&#39;), (&#39;f3&#39;, b&#39;C&#39;)])</span>
</pre></div>
</div>
<p><strong>Abstraction of repeat variables</strong></p>
<p>The following examples show how repeat variable can be parsed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;kurt&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;johnkurt&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;), (&#39;f2&#39;, b&#39;kurt&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;kurt&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;&#39;), (&#39;f2&#39;, b&#39;kurt&#39;)])</span>
</pre></div>
</div>
<p><strong>Specialization of repeat variables</strong></p>
<p>The following examples show how repeat variable can be specialized:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;johnjohn&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">IPv4</span><span class="p">(),</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delimiter</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">child</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">dataType</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Repeat</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">nbRepeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">17</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Repeat.html#Repeat.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Repeat.Repeat"><code class="xref py py-class docutils literal notranslate"><span class="pre">Repeat</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="optional-domain">
<h3>Optional Domain<a class="headerlink" href="#optional-domain" title="Permalink to this headline">#</a></h3>
<p>In the API, the definition of a conditional variable is made through the Opt class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Opt.html#Opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt" title="Permalink to this definition">#</a></dt>
<dd><p>The Opt class is a node variable that represents a variable
that may or may not produce a value, either in abstraction or
specialization.</p>
<p>The Opt constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>child</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The optional variable element.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable (if None, the name will
be generated).</p></li>
</ul>
</dd>
</dl>
<p>The following code shows an example of the Opt usage.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Opt</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)),</span> <span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">Symbol</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span> <span class="ow">in</span> <span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Nodes/Opt.html#Opt.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt" title="netzob.Model.Vocabulary.Domain.Variables.Nodes.Opt.Opt"><code class="xref py py-class docutils literal notranslate"><span class="pre">Opt</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="modeling-fields-with-relationship-variables">
<h2>Modeling Fields with Relationship Variables<a class="headerlink" href="#modeling-fields-with-relationship-variables" title="Permalink to this headline">#</a></h2>
<p>The ZDL language defines constraints on variables, in order to handle relationships. Those constraints are leveraged during abstraction and specialization of messages. The API supports the following relationships.</p>
<section id="value-relationships">
<h3>Value Relationships<a class="headerlink" href="#value-relationships" title="Permalink to this headline">#</a></h3>
<p>In the API, the definition of a relationship with the value of another field is made through the Value class. This class enables the computation of the relationship result by a basic copy of the targeted field or by calling a callback function.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Value.html#Value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value" title="Permalink to this definition">#</a></dt>
<dd><p>The Value class is a variable whose content is the value of another field.</p>
<p>It is possible to define a field so that its value is equal to the
value of another field, on which an operation can be
performed.</p>
<p>The Value constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> or <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The targeted object of the relationship. If a <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> is provided, it will be normalized by the associated <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable. If None, the name
will be generated.</p></li>
<li><p><strong>operation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>, optional) – An optional transformation operation to be
applied to the targeted field value, through a callback.
The default is None.</p></li>
</ul>
</dd>
</dl>
<p>The Value class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The variable that is required before computing
the value of this relation.</p></li>
<li><p><strong>operation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>) – Defines the operation to be performed on the found value.
The prototype of this callback is detailed below.</p></li>
</ul>
</dd>
</dl>
<p><strong>Callback prototype</strong></p>
<p>The callback function that can be used to specify a complex
relationship in the <code class="docutils literal notranslate"><span class="pre">operation</span></code> parameter has the following
prototype:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">cbk_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>bitarray</em>) – contains the current data of the targeted field.</p></li>
<li><p><strong>path</strong> (<em>object</em>) – data structure that allows access to the values of the
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>
element.</p></li>
<li><p><strong>variable</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value"><em>Value</em></a>) – the current Value variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The callback function should return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> representing the computed data during
specialization or abstraction. In the latter case, if
the callback function does not succeed to parse the
data, it should return the <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> value. The length of the computed data may differ from the length of the targeted data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code></p>
</dd>
</dl>
</dd></dl>

<p>Access to <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>
values is done through the <code class="docutils literal notranslate"><span class="pre">path</span></code>, thanks to its methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">hasData()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">getData()</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">path.hasData(variable)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code> telling if a data has
been specialized or parsed for the Value variable
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">path.getData(variable)</span></code> will return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> that corresponds
to the data specialized or parsed for the Value variable
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
</ul>
<p>The callback function is expected to implement relationship
operations based on the provided data.</p>
<p><strong>Value usage</strong></p>
<p>The following example shows how to define a field with a copy of
another field value, in specialization mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">f0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">fheader</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;abcdabcd&#39;</span>
</pre></div>
</div>
<p>The following example shows how to define a field with a copy of
another field value, in abstraction mode:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john;john!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">f1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;), (&#39;f2&#39;, b&#39;;&#39;), (&#39;f3&#39;, b&#39;john&#39;), (&#39;f4&#39;, b&#39;!&#39;)])</span>
</pre></div>
</div>
<p><strong>Value field with a variable as a target</strong></p>
<p>The following example shows the specialization process of a Value
field whose target is a variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;john;john!&#39;</span>
</pre></div>
</div>
<p><strong>Specialization of Value objects</strong></p>
<p>The following examples show the specialization process of Value
objects. The first example illustrates a case where the Value
variable is placed before the targeted variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">f1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;john;john!&#39;</span>
</pre></div>
</div>
<p>The second example illustrates a case where the Value variable is
placed after the targeted variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">f3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;john;john!&#39;</span>
</pre></div>
</div>
<p><strong>Transformation operation on targeted field value</strong></p>
<p>A named callback function can be used to specify a more complex
relationship. The following example shows a relationship where the
computed value corresponds to the reversed bits of the targeted
field value. The <code class="docutils literal notranslate"><span class="pre">data</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">cbk</span></code> function contains a
bitarray object of the targeted field value. The <code class="docutils literal notranslate"><span class="pre">cbk</span></code> function
returns a bitarray object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cbk</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">ret</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">... </span>   <span class="n">ret</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">bitarray</span><span class="p">(</span><span class="s1">&#39;10000000&#39;</span><span class="p">):</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="n">ret</span>
<span class="gp">... </span>   <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Value</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">operation</span> <span class="o">=</span> <span class="n">cbk</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b&#39;\x01\x80&#39;</span>
</pre></div>
</div>
<p>Callback functions are also triggered during data abstraction. In
the next portion of the example, the previously specialized data
is abstracted according to the field definition.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;\x01&#39;), (&#39;f1&#39;, b&#39;\x80&#39;)])</span>
</pre></div>
</div>
<p>If the targeted field (<code class="docutils literal notranslate"><span class="pre">f0</span></code>) does not contain the expected data,
the callback function should return <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, indicating that the
relationship does not apply. In this case, the abstraction process
will return an exception.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02\x80</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;f&#39;, cannot abstract the data: &#39;b&#39;\x02\x80&#39;&#39;. Error: &#39;No parsing path returned while parsing &#39;b&#39;\x02\x80&#39;&#39;&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Value.html#Value.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Value.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="size-relationships">
<h3>Size Relationships<a class="headerlink" href="#size-relationships" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.125</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Size.html#Size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size" title="Permalink to this definition">#</a></dt>
<dd><p>The Size class is a variable whose content is the size of other field values.</p>
<p>It is possible to define a field so that its value is equal to the
size of another field, or group of fields (potentially including
itself).</p>
<p>By default, the computed size expresses an amount of bytes. It is
possible to change this behavior by using the <code class="docutils literal notranslate"><span class="pre">factor</span></code>
and <code class="docutils literal notranslate"><span class="pre">offset</span></code> parameters.</p>
<p>The Size constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> (a <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> or a <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a> or a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> or <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The targeted objects of the relationship. If a <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> is provided, it will be normalized by the associated <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><strong>dataType</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>, optional) – Specify that the produced value should be
represented according to this dataType. If None, default
value is Raw(nbBytes=1).</p></li>
<li><p><strong>factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Specify that the initial size value (always
expressed in bits) should be multiplied by this
factor. The default value is <code class="docutils literal notranslate"><span class="pre">1.0/8</span></code>. For example, to
express a size in bytes, the factor should be <code class="docutils literal notranslate"><span class="pre">1.0/8</span></code>,
whereas to express a size in bits, the factor should be
<code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p></li>
<li><p><strong>offset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – Specify that an offset value should be added to
the final size value (after applying the factor
parameter). The default value is 0.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable. If None, the name
will be generated.</p></li>
</ul>
</dd>
</dl>
<p>The Size class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> (a list of
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The list of variables that are required before computing
the value of this relation</p></li>
<li><p><strong>dataType</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>) – The type of the data.</p></li>
<li><p><strong>factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Defines the multiplication factor to apply to the targeted
length.</p></li>
<li><p><strong>offset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Defines the offset to apply to the computed length.</p></li>
</ul>
</dd>
</dl>
<p>The following example shows how to define a size field with a
Raw dataType:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">([</span><span class="n">f0</span><span class="p">],</span> <span class="n">dataType</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example shows how to define a size field with a
Raw dataType, along with specifying the <code class="docutils literal notranslate"><span class="pre">factor</span></code> and <code class="docutils literal notranslate"><span class="pre">offset</span></code> parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">dataType</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="mf">1.</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># == 4 bytes minimum * 8 bits * a factor of 1./8 + an offset of 4</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In this example, the <em>f2</em> field is a size field where its value is
equal to the size of the concatenated values of fields <em>f0</em> and
<em>f1</em>. The <em>dataType</em> parameter specifies that the produced value
should be represented as a <code class="docutils literal notranslate"><span class="pre">Raw</span></code>. The <em>factor</em> parameter
specifies that the initial size value (always expressed in bits)
should be multiplied by <code class="docutils literal notranslate"><span class="pre">1.0/8</span></code> (in order to retrieve the amount of
bytes). The <em>offset</em> parameter specifies that the final size value
should be computed by adding 4 bytes.</p>
<p>The following example shows how to define a size field so that its
value depends on a list of non-consecutive fields:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;_&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f4</span><span class="p">,</span> <span class="n">f5</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">,</span> <span class="n">f5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;=#\x04%_&#39;</span>
</pre></div>
</div>
<p>In the following example, a size field is declared after its
targeted field. This shows that the field order does not impact
the relationship computations.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="n">f0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span> <span class="o">&lt;=</span> <span class="mi">6</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the following example, a size field is declared before the
targeted field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">,</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="n">f2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">6</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Size field with fields and variables as target</strong></p>
<p>The following examples show the specialization process of a Size
field whose targets are both fields and variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">([</span><span class="n">d</span><span class="p">,</span> <span class="n">f1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x15</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">res</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Size</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">d</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x15</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">res</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Size field which targets itself</strong></p>
<p>The following example shows a Size field whose targets contain
itsef. In such case, the domain datatype (here, an <code class="docutils literal notranslate"><span class="pre">uint16</span></code>) is
used to compute the size of the length field (here, the datatype
occupies 2 bytes).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;len&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">28</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">Size</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">],</span> <span class="n">dataType</span><span class="o">=</span><span class="n">uint16</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">b&#39;\x00\x00\x00\x15\x00\x00\x00\x00z\x12\x10\xfe\x9a$)L\xc4\xbfL91&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;\x00&#39;), (&#39;f1&#39;, b&#39;\x00&#39;), (&#39;len&#39;, b&#39;\x00\x15&#39;), (&#39;f3&#39;, b&#39;\x00\x00\x00\x00&#39;), (&#39;f4&#39;, b&#39;z\x12\x10\xfe\x9a$)L\xc4\xbfL91&#39;)])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Size.html#Size.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Size.Size"><code class="xref py py-class docutils literal notranslate"><span class="pre">Size</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="padding-relationships">
<h3>Padding Relationships<a class="headerlink" href="#padding-relationships" title="Permalink to this headline">#</a></h3>
<p>In the API, it is possible to model a structure with a padding through the Padding class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Padding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">once</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Padding.html#Padding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding" title="Permalink to this definition">#</a></dt>
<dd><p>The Padding class is a variable whose content makes it possible to produce a
padding value that can be used to align a structure to a fixed
size.</p>
<p>The Padding constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> or a <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a> or a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> or <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The targeted objects of the relationship. If a <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> is provided, it will be normalized by the associated <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>.</p></li>
<li><p><strong>data</strong> (a <a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>
or a <code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code>, required) – Specify that the produced value should be represented
according to this data. A callback function,
returning the padding value, can be used here.</p></li>
<li><p><strong>modulo</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, required) – Specify the expected modulo size. The padding value
will be computed so that the whole structure aligns
to this value. This typically corresponds to a
block size in cryptography.</p></li>
<li><p><strong>once</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – If True, the padding is applied only if the total size of the
targeted fields is smaller than the modulo value.
Default value is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – Specify that the length of the targeted structure (always
expressed in bits) should be
multiplied by this factor. The default value is <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.
For example, to express a length in bytes, the factor should
be <code class="docutils literal notranslate"><span class="pre">1.0/8</span></code>, whereas to express a length in bits, the
factor should be <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p></li>
<li><p><strong>offset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, optional) – Specify a value in bits that should be added to the length
of the targeted structure (after applying the factor
parameter). The default value is 0.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the variable. If None, the name
will be generated.</p></li>
</ul>
</dd>
</dl>
<p>The Padding class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> (a list of
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>) – The list of variables that are required before computing
the value of this relation</p></li>
<li><p><strong>dataType</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Types.AbstractType.AbstractType" title="netzob.Model.Vocabulary.Types.AbstractType.AbstractType"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractType</span></code></a>) – The type of the data.</p></li>
<li><p><strong>factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Defines the multiplication factor to apply to the targeted
length.</p></li>
<li><p><strong>offset</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Defines the offset to apply to the computed length.</p></li>
</ul>
</dd>
</dl>
<p><strong>Callback prototype</strong></p>
<p>The callback function that can be used in the <code class="docutils literal notranslate"><span class="pre">data</span></code>
parameter to specify the padding value has the following prototype:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">cbk_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – corresponds to the current size in bits of
the targeted structure.</p></li>
<li><p><strong>modulo</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – corresponds to the expected modulo size in bits.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The callback function should return a <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code></p>
</dd>
</dl>
</dd></dl>

<p><strong>Padding examples</strong></p>
<p>The following code illustrates a padding with a modulo integer.
Here, the padding data <code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code> is repeated <code class="docutils literal notranslate"><span class="pre">n</span></code>
times, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is computed by decrementing the modulo number,
<code class="docutils literal notranslate"><span class="pre">128</span></code>, by the current length of the targeted structure. The
padding length is therefore equal to <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">-</span> <span class="pre">(10+2)*8</span> <span class="pre">=</span> <span class="pre">32</span></code> bits.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;##&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Padding</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">128</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>
<span class="go">b&#39;\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="go">128</span>
</pre></div>
</div>
<p>The following code illustrates a padding with the use of the
<code class="docutils literal notranslate"><span class="pre">offset</span></code> parameter, where the targeted field sizes are decremented by
8 when computing the padding value length.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;##&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Padding</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>
<span class="go">b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="go">120</span>
</pre></div>
</div>
<p>The following code illustrates a padding with the use of the
<code class="docutils literal notranslate"><span class="pre">factor</span></code> parameter, where the targeted field sizes are multiplied by <code class="docutils literal notranslate"><span class="pre">1.0/2</span></code>
before computing the padding value length.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;##&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Padding</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="go">256</span>
</pre></div>
</div>
<p>The following code illustrates a padding with the use of a
callback function that helps to determine the padding value. In
this example, the padding value is an incrementing integer.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;##&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cbk_data</span><span class="p">(</span><span class="n">current_length</span><span class="p">,</span> <span class="n">modulo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">length_to_pad</span> <span class="o">=</span> <span class="n">modulo</span> <span class="o">-</span> <span class="p">(</span><span class="n">current_length</span> <span class="o">%</span> <span class="n">modulo</span><span class="p">)</span>  <span class="c1"># Length in bits</span>
<span class="gp">... </span>    <span class="n">length_to_pad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">length_to_pad</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># Length in bytes</span>
<span class="gp">... </span>    <span class="n">res_bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length_to_pad</span><span class="p">))])</span>
<span class="gp">... </span>    <span class="n">res_bits</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">res_bits</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">res_bytes</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">res_bits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Padding</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">cbk_data</span><span class="p">,</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">128</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>
<span class="go">b&#39;\x00\x01\x02\x03&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="go">128</span>
</pre></div>
</div>
<p>The following code illustrates a padding with the use of a
callback function that helps to determine the padding value. In
this example, the padding value is a repetition of an incrementing
integer, thus implementing the PKCS #7 padding.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;##&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cbk_data</span><span class="p">(</span><span class="n">current_length</span><span class="p">,</span> <span class="n">modulo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">length_to_pad</span> <span class="o">=</span> <span class="n">modulo</span> <span class="o">-</span> <span class="p">(</span><span class="n">current_length</span> <span class="o">%</span> <span class="n">modulo</span><span class="p">)</span>  <span class="c1"># Length in bits</span>
<span class="gp">... </span>    <span class="n">length_to_pad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">length_to_pad</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># Length in bytes</span>
<span class="gp">... </span>    <span class="n">res_bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">length_to_pad</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">length_to_pad</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">res_bits</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">res_bits</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">res_bytes</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">res_bits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Padding</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">cbk_data</span><span class="p">,</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">128</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">12</span><span class="p">:]</span>
<span class="go">b&#39;\x04\x04\x04\x04&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="go">128</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Padding.html#Padding.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Padding.Padding"><code class="xref py py-class docutils literal notranslate"><span class="pre">Padding</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="checksum-relationships">
<h3>Checksum Relationships<a class="headerlink" href="#checksum-relationships" title="Permalink to this headline">#</a></h3>
<p>The ZDL language enables the definition of checksum relationships between fields.</p>
<p><strong>Checksum API</strong></p>
<p>As an example, the API for the CRC16 checksum is as follows:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CRC16</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Checksums/CRC16.html#CRC16"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16" title="Permalink to this definition">#</a></dt>
<dd><p>This class implements the CRC16 function.</p>
<p>The constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>targets</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, required) – The targeted fields of the relationship.</p>
</dd>
</dl>
<p>The following example shows how to create a checksum relationship
with another field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xaa\xbb</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CRC16</span><span class="p">([</span><span class="n">f1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span>
<span class="go">b&#39;aabb3ed3&#39;</span>
</pre></div>
</div>
<p>The following example shows how to create a checksum relationship
with a group of fields:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xaa\xbb</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xcc\xdd</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xee\xff</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CRC16</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span>
<span class="go">b&#39;aabbccddeeff5e9b&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractChecksum</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p><strong>Available checksums</strong></p>
<p>The following list shows the available checksums. The API for those checksums are similar to the CRC16 API.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Checksums.CRC16.CRC16"><code class="xref py py-class docutils literal notranslate"><span class="pre">CRC16(targets)</span></code></a></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CRC16DNP(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CRC16Kermit(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CRC16SICK(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CRC32(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CRCCCITT(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">InternetChecksum(targets)</span></code> (used in ICMP, UDP, IP, TCP protocols, as specified in <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1071.html"><strong>RFC 1071</strong></a>).</p></li>
</ul>
</section>
<section id="hash-relationships">
<h3>Hash Relationships<a class="headerlink" href="#hash-relationships" title="Permalink to this headline">#</a></h3>
<p>The ZDL language enables the definition of hash relationships between fields.</p>
<p><strong>Hash API</strong></p>
<p>As an example, the API for the MD5 hash is as follows:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MD5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Hashes/MD5.html#MD5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5" title="Permalink to this definition">#</a></dt>
<dd><p>This class implements the MD5 relationships between fields.</p>
<p>The constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>targets</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, required) – The targeted fields of the relationship.</p>
</dd>
</dl>
<p>The following example shows how to create a hash relation with
another field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xaa\xbb</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">MD5</span><span class="p">([</span><span class="n">f1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span>
<span class="go">b&#39;aabb58cea1f6b2b06520613e09af90dc1c47&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractHash</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p><strong>Available hashes</strong></p>
<p>The following list shows the available hashes. The API for those hashes are similar to the MD5 API.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hashes.MD5.MD5"><code class="xref py py-class docutils literal notranslate"><span class="pre">MD5(targets)</span></code></a></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA1(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA1_96(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA2_224(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA2_256(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA2_384(targets)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SHA2_512(targets)</span></code></p></li>
</ul>
</section>
<section id="hmac-relationships">
<h3>HMAC Relationships<a class="headerlink" href="#hmac-relationships" title="Permalink to this headline">#</a></h3>
<p>The ZDL language enables the definition of HMAC relationships between fields.</p>
<p><strong>HMAC API</strong></p>
<p>As an example, the API for the HMAC_MD5 is as follows:</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HMAC_MD5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Leafs/Hmacs/HMAC_MD5.html#HMAC_MD5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5" title="Permalink to this definition">#</a></dt>
<dd><p>This class implements the HMAC_MD5.</p>
<p>The constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>targets</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, required) – The targeted fields of the relationship.</p></li>
<li><p><strong>key</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, required) – The cryptographic key used in the hmac computation.</p></li>
</ul>
</dd>
</dl>
<p>The following example shows how to create a HMAC relation with
another field:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xaa\xbb</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">HMAC_MD5</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">specialize</span><span class="p">()))</span>
<span class="go">b&#39;aabbb71c98baa40dc8a49361816d5dc1eb25&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractHMAC</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p><strong>Available HMACs</strong></p>
<p>The following list shows the available HMACs. The API for those HMACs are similar to the HMAC_MD5 API.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5" title="netzob.Model.Vocabulary.Domain.Variables.Leafs.Hmacs.HMAC_MD5.HMAC_MD5"><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_MD5(targets,</span> <span class="pre">key)</span></code></a></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA1(targets,</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA1_96(targets,</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA2_224(targets,</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA2_256(targets,</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA2_384(targets,</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">HMAC_SHA2_512(targets,</span> <span class="pre">key)</span></code></p></li>
</ul>
</section>
</section>
<section id="modeling-symbols">
<span id="id3"></span><h2>Modeling Symbols<a class="headerlink" href="#modeling-symbols" title="Permalink to this headline">#</a></h2>
<p>In the API, symbol modeling is done through the Symbol class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><span class="pre">netzob.Model.Vocabulary.Field.Field</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">messages</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">netzob.Model.Vocabulary.Messages.AbstractMessage.AbstractMessage</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Symbol'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Symbol.html#Symbol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="Permalink to this definition">#</a></dt>
<dd><p>The Symbol class is a main component of the Netzob protocol model.</p>
<p>A symbol represents an abstraction of all messages of the same
type from a protocol perspective. A symbol structure is made of
fields.</p>
<p>The Symbol constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fields</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, optional) – The fields that participate in the symbol
definition, in the wire order. May be <code class="docutils literal notranslate"><span class="pre">None</span></code> (thus, a generic <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>
instance would be defined), especially when using Symbols
for reverse engineering (i.e. fields identification).</p></li>
<li><p><strong>messages</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractMessage</span></code>, optional) – The messages that are associated with the
symbol. May be <code class="docutils literal notranslate"><span class="pre">None</span></code> (thus, an empty <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>
would be defined), especially when
modeling a protocol from scratch (i.e. the
fields are already known).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the symbol. If not specified, the
default name will be “Symbol”.</p></li>
</ul>
</dd>
</dl>
<p>The Symbol class provides the following public variables:</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fields</strong> (a <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>) – The sorted list of sub-fields.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the symbol.</p></li>
<li><p><strong>description</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The description of the symbol.</p></li>
</ul>
</dd>
</dl>
<p><strong>Usage of Symbol for protocol modeling</strong></p>
<p>The Symbol class may be used to model a protocol from scratch, by
specifying its structure in terms of fields:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;aaaa&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot; # &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;bbbbbb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">symbol</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
<span class="go">Field - Data (String(&#39;aaaa&#39;))</span>
<span class="go">Field - Data (String(&#39; # &#39;))</span>
<span class="go">Field - Data (String(&#39;bbbbbb&#39;))</span>
</pre></div>
</div>
<p><strong>Usage of Symbol for protocol dissecting</strong></p>
<p>The Symbol class may be used to dissect a list of messages
according to the fields structure:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">RawMessage</span><span class="p">(</span><span class="s2">&quot;hello world&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">RawMessage</span><span class="p">(</span><span class="s2">&quot;hello earth&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">],</span> <span class="n">messages</span><span class="o">=</span><span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">f0      | f1      </span>
<span class="go">------- | --------</span>
<span class="go">&#39;hello&#39; | &#39; world&#39;</span>
<span class="go">&#39;hello&#39; | &#39; earth&#39;</span>
<span class="go">------- | --------</span>
</pre></div>
</div>
<p><strong>Usage of Symbol for protocol reverse engineering</strong></p>
<p>The Symbol class may be used is to do reverse engineering on a
list of captured messages of unknown/undocumented protocols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">RawMessage</span><span class="p">(</span><span class="s2">&quot;hello aaaa&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">RawMessage</span><span class="p">(</span><span class="s2">&quot;hello bbbb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">messages</span><span class="o">=</span><span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Format</span><span class="o">.</span><span class="n">splitStatic</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">str_data</span><span class="p">())</span>
<span class="go">Field-0  | Field-1</span>
<span class="go">-------- | -------</span>
<span class="go">&#39;hello &#39; | &#39;aaaa&#39; </span>
<span class="go">&#39;hello &#39; | &#39;bbbb&#39; </span>
<span class="go">-------- | -------</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Symbol.html#Symbol.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current object as well as all its dependencies. This
method returns a new object of the same type.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new object of the same type.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="netzob.Model.Vocabulary.Symbol.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.str_structure">
<span class="sig-name descname"><span class="pre">str_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Symbol.html#Symbol.str_structure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.str_structure" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a string which denotes the current symbol definition
using a tree display.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The current symbol represented as a string.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
<p>This example shows the rendering of a symbol with multiple
fields.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">14</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;symbol_name&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">str_structure</span><span class="p">())</span>
<span class="go">symbol_name</span>
<span class="go">|--  field1</span>
<span class="go">     |--   Data (String(nbChars=(0,8192)))</span>
<span class="go">|--  field2</span>
<span class="go">     |--   Data (Integer(10,100))</span>
<span class="go">|--  field3</span>
<span class="go">     |--   Data (Raw(nbBytes=14))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">str_structure</span><span class="p">())</span>
<span class="go">field1</span>
<span class="go">|--   Data (String(nbChars=(0,8192)))</span>
</pre></div>
</div>
<p>This example shows the rendering of a symbol where a Preset
configuration has been applied on several variables (the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fuzz()</span></code> method is explained in the fuzzing section).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field 1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var_agg</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">var_agg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field 2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field 3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;symbol 1&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">field1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x42</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(</span><span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">FuzzingMode</span><span class="o">.</span><span class="n">MUTATE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(</span><span class="n">field3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">str_structure</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">symbol 1</span>
<span class="go">|--  field 1</span>
<span class="go">     |--   Data (Raw(nbBytes=1)) [FuzzingMode.FIXED (b&#39;B&#39;)]</span>
<span class="go">|--  field 2</span>
<span class="go">     |--   Agg</span>
<span class="go">           |--   Data (Integer(0,255)) [FuzzingMode.MUTATE]</span>
<span class="go">           |--   Data (Integer(0,255))</span>
<span class="go">|--  field 3</span>
<span class="go">     |--   Data (Raw(nbBytes=1)) [FuzzingMode.GENERATE]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.abstract">
<span class="sig-name descname"><span class="pre">abstract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="netzob.Model.Vocabulary.Symbol.Symbol.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method is used to abstract the given
data bytes with the current symbol (or field) model. This method also works on fields, in order to abstract a <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> into a field object.</p>
<p>Similarly to the <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.specialize" title="netzob.Model.Vocabulary.Symbol.Symbol.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method, it is possible to
indicate a Preset configuration that will be used to check
content parsed for specific fields. However, for the
<a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="netzob.Model.Vocabulary.Symbol.Symbol.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method, it is only possible to specify field
names for keys of the Preset configuration. The reason of this
restriction is that the <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="netzob.Model.Vocabulary.Symbol.Symbol.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method returns an
<code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> containing also field names as keys.</p>
<p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="netzob.Model.Vocabulary.Symbol.Symbol.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, required) – The concrete message to abstract in symbol (or field).</p></li>
<li><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to check values in symbol (or field) structure obtained after message parsing.</p></li>
<li><p><strong>memory</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a>, optional) – A memory used to store variable values during
specialization and abstraction of sequence of symbols (or fields).
The default value is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The structure of the parsed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> where keys are <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> and values are <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractionException</span></code> if an error occurs while abstracting the data</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using the <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.abstract" title="netzob.Model.Vocabulary.Symbol.Symbol.abstract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code></a> method, it is
important to explicitly name all the fields with different
names, because the resulting OrderedDict will use field
names as its keys.</p>
</div>
<p><strong>Abstracting data into a field</strong></p>
<p>The following code shows an example of abstracting a data
according to a field definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;john, what&#39;s up in </span><span class="si">{}</span><span class="s2"> ?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="s1">&#39;Berlin&#39;</span><span class="p">]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f1a</span><span class="p">,</span> <span class="n">f2a</span><span class="p">,</span> <span class="n">f3a</span><span class="p">,</span> <span class="n">f4a</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;field-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">structured_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">structured_data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Berlin&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
<p><strong>Abstracting data into a symbol</strong></p>
<p>The following code shows an example of abstracting a data
according to a symbol definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;john, what&#39;s up in </span><span class="si">{}</span><span class="s2"> ?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="s1">&#39;Berlin&#39;</span><span class="p">]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4a</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1a</span><span class="p">,</span> <span class="n">f2a</span><span class="p">,</span> <span class="n">f3a</span><span class="p">,</span> <span class="n">f4a</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Symbol-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">structured_data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">structured_data</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Berlin&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
<p><strong>Usage of Symbol for traffic generation and parsing</strong></p>
<p>A Symbol class may be used to generate concrete messages according
to its field definition, through the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> method, and
may also be used to abstract a concrete message into its
associated symbol through the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;aaaa&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot; # &quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;bbbbbb&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">concrete_message</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">concrete_message</span>
<span class="go">b&#39;aaaa # bbbbbb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">concrete_message</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f0&#39;, b&#39;aaaa&#39;), (&#39;f1&#39;, b&#39; # &#39;), (&#39;f2&#39;, b&#39;bbbbbb&#39;)])</span>
</pre></div>
</div>
<p><strong>Usage of Preset during message abstraction</strong></p>
<p>The following code shows an example of abstracting a data
according to a symbol definition and a defined Preset configuration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;question&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;, what&#39;s up in &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Alt</span><span class="p">([</span><span class="s2">&quot;Paris&quot;</span><span class="p">,</span> <span class="s2">&quot;Berlin&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot; ?&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Symbol-john&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We build a Preset configuration indicating that we expect &quot;Paris&quot; for the field f3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Paris&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john, what&#39;s up in Berlin ?&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;Symbol-john&#39;, can abstract the data: &#39;john, what&#39;s up in Berlin ?&#39;, but some parsed values do not match the expected preset.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;john, what&#39;s up in Paris ?&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_structure</span>
<span class="go">OrderedDict([(&#39;name&#39;, b&#39;john&#39;), (&#39;question&#39;, b&quot;, what&#39;s up in &quot;), (&#39;city&#39;, b&#39;Paris&#39;), (&#39;mark&#39;, b&#39; ?&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Symbol.html#Symbol.count"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.count" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.count" title="netzob.Model.Vocabulary.Symbol.Symbol.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> method computes the expected number of unique
messages produced, considering the initial symbol model and the
preset configuration of fields.</p>
<p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.count" title="netzob.Model.Vocabulary.Symbol.Symbol.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> method expects the following parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables. This configuration will impact the expected number of unique messages the symbol would produce.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The number of unique values the symbol specialization can produce.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The theoretical value returned by <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.count" title="netzob.Model.Vocabulary.Symbol.Symbol.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>
may be huge. Therefore, we force the returned value to be
<code class="xref py py-attr docutils literal notranslate"><span class="pre">MAXIMUM_POSSIBLE_VALUES</span></code> (86400000000), if the
theoretical result is beyond this threshold. This limit
corresponds to 1 day of data generation based on a generation
bandwith of 1 million per second.</p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Symbol definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.Fuzzing.Generators.DeterministGenerator</span> <span class="kn">import</span> <span class="n">DeterministGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint16</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Count the expected number of unique produced messages</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>  <span class="c1">#  Here, the following computation is done: 951*256*256 (f1 is able to produce 1000-50+1=951 possible values, based on its interval)</span>
<span class="go">62324736</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify a preset configuration for field &#39;f2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>  <span class="c1"># Here, the following computation is done: 951*1*256 (as the f2 field value is set to 42, f2 can now produce only 1 possible value)</span>
<span class="go">243456</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify a preset configuration for field &#39;f3&#39; by activating fuzzing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(</span><span class="n">f3</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="s1">&#39;determinist&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>  <span class="c1"># Here, the following computation is done: 951*1*29 (29 corresponds to the number of possible values generated by the determinist generator)</span>
<span class="go">27579</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.getField">
<span class="sig-name descname"><span class="pre">getField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.getField" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve a sub-field based on its name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, required) – the name of the <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The sub-field object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>KeyError</strong> – when the field has not been found</p>
</dd>
</dl>
<p>The following example shows how to retrieve a sub-field based
on its name:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;f3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;fheader&quot;</span><span class="p">)</span>  <span class="c1"># create a Field named &#39;fheader&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fheader</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">]</span> <span class="c1"># this Field is parent of 3 existing Fields</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">fheader</span><span class="o">.</span><span class="n">getField</span><span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">))</span> <span class="c1"># get the sub-field named &#39;f2&#39;</span>
<span class="go">&lt;class &#39;netzob.Model.Vocabulary.Field.Field&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getField</span><span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">))</span> <span class="c1"># get the field named &#39;f2&#39; in the symbol</span>
<span class="go">&lt;class &#39;netzob.Model.Vocabulary.Field.Field&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Symbol.Symbol.specialize">
<span class="sig-name descname"><span class="pre">specialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Symbol.html#Symbol.specialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Symbol.Symbol.specialize" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.specialize" title="netzob.Model.Vocabulary.Symbol.Symbol.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method is intended to produce concrete
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> data based on the symbol model and the current <a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a> configuration. This method
returns a Python generator that in turn provides data
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> object at each call to <code class="docutils literal notranslate"><span class="pre">next(generator)</span></code>.</p>
<p>The specialize() method expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, optional) – The configuration used to parameterize values in fields and variables.</p></li>
<li><p><strong>memory</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a>, optional) – A memory used to store variable values during
specialization and abstraction of successive
symbols, especially to handle inter-symbol
relationships. If None, a temporary memory is
created by default and used internally during the scope of the
specialization process.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A generator that provides data <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> at each call to <code class="docutils literal notranslate"><span class="pre">next(generator)</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator[bytes]</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerationException</span></code> if an error occurs while specializing the field.</p>
</dd>
</dl>
<p>The following example shows the <a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol.specialize" title="netzob.Model.Vocabulary.Symbol.Symbol.specialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code></a> method used for a
field which contains a String field and a Size field.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s1">&#39;John&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">())</span>
<span class="go">b&#39;hello John&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="configuring-symbol-content">
<h2>Configuring Symbol Content<a class="headerlink" href="#configuring-symbol-content" title="Permalink to this headline">#</a></h2>
<section id="setting-field-values">
<h3>Setting Field Values<a class="headerlink" href="#setting-field-values" title="Permalink to this headline">#</a></h3>
<p>In the API, it is possible to control values that will be used in
fields during symbol specialization. Such configuration can be done
through the Preset class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Preset.Preset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Preset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'preset'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Preset.html#Preset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Preset.Preset" title="Permalink to this definition">#</a></dt>
<dd><p>The Preset class is used to configure symbol specialization, by
fixing the expected value of a field or a variable. The Preset
component also works at the Field level, in the context of field
specialization. The Preset class is also the component responsible
for format message fuzzing (see below).</p>
<p>The Preset constructor expects some parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>symbol</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Symbol.Symbol" title="netzob.Model.Vocabulary.Symbol.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a> or <a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>, required) – A symbol (or field) on which to apply Preset configuration.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the preset configuration. Default value is ‘preset’.</p></li>
</ul>
</dd>
</dl>
<p>The Preset works like a Python <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> with a key:value principle:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Field.Field" title="netzob.Model.Vocabulary.Field.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>,
or <a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable" title="netzob.Model.Vocabulary.Domain.Variables.AbstractVariable.AbstractVariable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>, required) – The field or variable for which we want to set the value.</p></li>
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or the type associated with of the overridden field
variable, required) – The configured value for the field or value.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can only set (e.g. <code class="docutils literal notranslate"><span class="pre">preset[field]</span> <span class="pre">=</span> <span class="pre">b'\xaa\xbb'</span></code>) or unset (e.g. <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">preset[field]</span></code>) a Preset configuration on a field or variable. However, it is not allowed to access an item of the Preset configuration (e.g. <code class="docutils literal notranslate"><span class="pre">new_var</span> <span class="pre">=</span> <span class="pre">preset[field]</span></code>).</p>
</div>
<p><strong>The different ways to specify a field to preset</strong></p>
<p>It is possible to parameterize fields during symbol (or field)
specialization. Values configured for fields will override any
field definition, constraints or relationship dependencies.</p>
<p>The Preset configuration accepts a sequence of keys and values,
where keys correspond to the fields or variables in the symbol that we want
to override, and values correspond to the overriding
content. Keys are either expressed as field/variable object or strings
containing field/variable accessors when names are used (such as
in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">Field(name=&quot;udp.dport&quot;)</span></code>). Values are either
expressed as <code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> (as it is
the internal type for variables in the Netzob library), as
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> or in the type associated with of the overridden field
variable.</p>
<p>The following code shows the definition of a simplified UDP
header that will be later used as base example. This UDP
header is made of one named field containing a destination
port, and a named field containing a payload:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_dport</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;udp.dport&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Integer</span><span class="p">(</span><span class="n">unitSize</span><span class="o">=</span><span class="n">UnitSize</span><span class="o">.</span><span class="n">SIZE_8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_payload</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;udp.payload&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol_udp</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;udp&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f_dport</span><span class="p">,</span> <span class="n">f_payload</span><span class="p">])</span>
</pre></div>
</div>
<p>The four following codes show the same way to express the
parameterized <strong>values</strong> during specialization of the
<code class="docutils literal notranslate"><span class="pre">udp_dport</span></code> and <code class="docutils literal notranslate"><span class="pre">udp_payload</span></code> fields:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol_udp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_dport</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span>              <span class="c1"># udp.dport expects an int or an Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_payload</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xaa\xbb</span><span class="s2">&quot;</span>   <span class="c1"># udp.payload expects a bytes object or a Raw object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol_udp</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\x00\x0b\xaa\xbb&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol_udp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.dport&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span>              <span class="c1"># udp.dport expects an int or an Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.payload&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xaa\xbb</span><span class="s2">&quot;</span>   <span class="c1"># udp.payload expects a bytes object or a Raw object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol_udp</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\x00\x0b\xaa\xbb&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol_udp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.dport&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uint16</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>          <span class="c1"># udp.dport expects an int or an Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.payload&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xaa\xbb</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># udp.payload expects a bytes object or a Raw object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol_udp</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\x00\x0b\xaa\xbb&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol_udp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.dport&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="s1">&#39;00001011&#39;</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s2">&quot;udp.payload&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="s1">&#39;1010101010111011&#39;</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol_udp</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\x0b\xaa\xbb&#39;</span>
</pre></div>
</div>
<p>The previous example shows the use of BitArray as dict
values. BitArray are always permitted for any parameterized
field, as it is the internal type for variables in the Netzob
library.</p>
<p>A preset value bypasses all the constraint checks on the field definition.
In the following example, it is used to bypass a size field definition.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Raw</span><span class="p">(</span><span class="n">nbBytes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitarray</span><span class="p">(</span><span class="s1">&#39;11111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\xff\x10\xdb\xf7\x07i\xec\xfb\x8eR\x11\xfa\xa7&amp;\x7f&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a sub-field</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2_1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2_2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f2_1</span><span class="p">,</span> <span class="n">f2_2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f2_1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;\xb8A\x16&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;\xb8A\xd7&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;\xb8AG&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field that contains sub-fields</strong></p>
<p>This should trigger an exception as it is only possible to fix a value to leaf fields.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2_1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2_2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">([</span><span class="n">f2_1</span><span class="p">,</span> <span class="n">f2_2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">Exception</span>: <span class="n">Cannot set a fixed value on a field that contains sub-fields</span>
</pre></div>
</div>
<p><strong>Fixing the value of a leaf variable</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_agg</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v_agg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A\xb5&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A\xc3&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A\xd7&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a node variable</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_agg</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v_agg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">v_agg</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41\x42\x43</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field, by relying on a provided generator</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_generator</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x42</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x43</span><span class="s1">&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">generator raised StopIteration</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field, by relying on a provided iterator</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x42</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x43</span><span class="s1">&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_iter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">generator raised StopIteration</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field, by relying on a provided function</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_callable</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x42</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x43</span><span class="s1">&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_callable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;B&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a field through its name</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a variable leaf through its name</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_agg</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v_agg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v_agg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s1">&#39;v1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41\x42\x43</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC\xe9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABCY&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC\x9b&#39;</span>
</pre></div>
</div>
<p><strong>Fixing the value of a variable node through its name</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_agg</span> <span class="o">=</span> <span class="n">Agg</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v_agg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">v_agg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="s1">&#39;v_agg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41\x42\x43</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;ABC&#39;</span>
</pre></div>
</div>
<p><strong>Unfixing the value of a field</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">uint8</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;field 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">([</span><span class="n">f1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x41</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">preset</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages_gen</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">messages_gen</span><span class="p">)</span>
<span class="go">b&#39;\xb9&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Preset.Preset.bulk_set">
<span class="sig-name descname"><span class="pre">bulk_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Preset.html#Preset.bulk_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Preset.Preset.bulk_set" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset.bulk_set" title="netzob.Model.Vocabulary.Preset.Preset.bulk_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bulk_set()</span></code></a> method inserts multiple items at once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>items</strong> (<em>dict</em><em>, </em><em>required</em>) – the mapping to merge into the current object</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f_data1</span><span class="p">,</span> <span class="n">f_data2</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">presets</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s2">&quot;data1&quot;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>  <span class="c1"># ASCII value for &#39;*&#39;</span>
<span class="gp">... </span>    <span class="s2">&quot;data2&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">bulk_set</span><span class="p">(</span><span class="n">presets</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span>
<span class="go">b&#39;*\xff&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Preset.Preset.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Preset.html#Preset.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Preset.Preset.clear" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset.clear" title="netzob.Model.Vocabulary.Preset.Preset.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear</span></code></a> method clear the preset
and fuzzing configuration.</p>
<p>Example of clearing the Preset configuration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># This is necessary only for unit test purpose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f_data1</span><span class="p">,</span> <span class="n">f_data2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_data1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_data2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;\x01\x02&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">))</span>
<span class="go">b&#39;EW&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Preset.Preset.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Preset.html#Preset.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Preset.Preset.copy" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset.copy" title="netzob.Model.Vocabulary.Preset.Preset.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy</span></code></a> method copies the current preset
configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A copy of the current preset configuration.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method will linked the Preset configuration of the associated symbol to the new created Preset instance.</p>
</div>
<p>Example of copying the Preset configuration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f_data1</span><span class="p">,</span> <span class="n">f_data2</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_data1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preset</span><span class="p">[</span><span class="n">f_data2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Copy the preset configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span> <span class="o">=</span> <span class="n">preset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Update new preset configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span><span class="p">[</span><span class="n">f_data1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x03</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span><span class="p">[</span><span class="n">f_data2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x04</span><span class="s1">&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate data with the new preset configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">new_preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">b&#39;\x03\x04&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate data with the first preset configuration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">b&#39;\x01\x02&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Preset.Preset.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_preset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Preset.html#Preset.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Preset.Preset.update" title="Permalink to this definition">#</a></dt>
<dd><p>The <a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset.update" title="netzob.Model.Vocabulary.Preset.Preset.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update</span></code></a> method updates the current
preset and fuzzing configuration with a preset configuration
given in parameter. Only the configuration of the current
preset is updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_preset</strong> (<a class="reference internal" href="#netzob.Model.Vocabulary.Preset.Preset" title="netzob.Model.Vocabulary.Preset.Preset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preset</span></code></a>, required) – The preset configuration from which we want to retrieve the information.</p>
</dd>
</dl>
<p>Example of updating the Preset configuration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_data2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">int8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sym&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f_data1</span><span class="p">,</span> <span class="n">f_data2</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create main preset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main_preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main_preset</span><span class="p">[</span><span class="n">f_data1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main_preset</span><span class="p">[</span><span class="n">f_data2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x02</span><span class="s1">&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create new preset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span> <span class="o">=</span> <span class="n">Preset</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span><span class="p">[</span><span class="n">f_data1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x03</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_preset</span><span class="p">[</span><span class="n">f_data2</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x04</span><span class="s1">&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate data according to the last defined preset (i.e. the &#39;new&#39; preset)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">new_preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">b&#39;\x03\x04&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate data according to the first defined preset (i.e. the &#39;main&#39; preset)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">main_preset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">b&#39;\x01\x02&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="symbol-with-no-content">
<h3>Symbol with no Content<a class="headerlink" href="#symbol-with-no-content" title="Permalink to this headline">#</a></h3>
<p>A specific symbol may be used in the state machine to represent the
absence of received symbol (EmptySymbol), when listening for incoming
message, or the fact that nothing is going to be sent, when attempting
to send something to the remote peer.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.EmptySymbol.EmptySymbol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EmptySymbol</span></span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/EmptySymbol.html#EmptySymbol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.EmptySymbol.EmptySymbol" title="Permalink to this definition">#</a></dt>
<dd><p>An empty symbol is a special type of symbol that represents the
fact of having received nothing or having nothing to send. An
EmptySymbol is only produced by the automaton, and thus should not
be instantiated.</p>
</dd></dl>

</section>
</section>
<section id="relationships-between-symbols-and-the-environment">
<h2>Relationships between Symbols and the Environment<a class="headerlink" href="#relationships-between-symbols-and-the-environment" title="Permalink to this headline">#</a></h2>
<p>In the API, a memory capability is provided in order to support
relationships between variables, as well as variable persistence
during the specialization and abstraction processes. This capability
is described in the Memory class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Memory</span></span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="Permalink to this definition">#</a></dt>
<dd><p>This class provides a memory, used to store variable values (in bitarray) in a persisting and independent way.</p>
<p>To compute or verify the constraints and relationships that
participate to the definition of the fields, the Netzob library
relies on a memory. This memory stores the values of previously
captured or emitted fields. More precisely, the Memory contains
all the field variables that are needed according to the field
definition during the abstraction and specialization processes.</p>
<p><strong>Relationships between fields of successive messages</strong></p>
<p>The following example shows how to define a relationship
between a received message and the next message to send. A
memory is used to store the value of each variable. During the
first call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> on the <code class="docutils literal notranslate"><span class="pre">s1</span></code> symbol, the
value associated to the field <code class="docutils literal notranslate"><span class="pre">f3</span></code> is notably stored in
memory, so that it can be retrieved when calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> on the <code class="docutils literal notranslate"><span class="pre">s2</span></code> symbol. In order to create
persistence for the <code class="docutils literal notranslate"><span class="pre">f3</span></code> field, it is mandatory to use the
<code class="docutils literal notranslate"><span class="pre">scope</span></code> parameter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">MESSAGE</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;S1&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;master&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="n">f3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F6&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f4</span><span class="p">,</span> <span class="n">f5</span><span class="p">,</span> <span class="n">f6</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;S2&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span> <span class="o">==</span> <span class="n">m2</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Relationships between a message field and the environment</strong></p>
<p>The following example shows how to define a relationship
between a message to send and an environment variable. The
symbol is first defined, and then an environment variable is
created. The first step consists in overloading the definition
domain of the <code class="docutils literal notranslate"><span class="pre">f9</span></code> field to link the environment variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Symbol definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;master&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F7&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F8&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F9&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f7</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">f9</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Environment variables definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;env1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">env1</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;John&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overloading f9 field definition to link the environment variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="n">env1</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Symbol specialization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s3</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="go">b&#39;master&gt;John&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Copy the current memory in a new memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new memory containing the same entries as the current memory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">uint8</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">uint8</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
<span class="go">bitarray(&#39;01100100&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
<span class="go">bitarray(&#39;01100100&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span><span class="o">.</span><span class="n">bytereverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
<span class="go">bitarray(&#39;00100110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
<span class="go">bitarray(&#39;01100100&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.forget">
<span class="sig-name descname"><span class="pre">forget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory.forget"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.forget" title="Permalink to this definition">#</a></dt>
<dd><p>Forgets any memorized value of the provided variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code>, required) – The variable for which we want to forget the value in memory.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variable</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">hasValue</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">forget</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">hasValue</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.getValue">
<span class="sig-name descname"><span class="pre">getValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory.getValue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.getValue" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value memorized for the provided variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code>, required) – The variable for which we want to retrieve the value in memory.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The value in memory.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variable</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;hello&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.hasValue">
<span class="sig-name descname"><span class="pre">hasValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory.hasValue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.hasValue" title="Permalink to this definition">#</a></dt>
<dd><p>Returns true if the memory contains a value for the provided variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code>, required) – The variable to look for in the memory.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the memory contains a value for the variable.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variable</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">hasValue</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variable2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">hasValue</span><span class="p">(</span><span class="n">variable2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.memorize">
<span class="sig-name descname"><span class="pre">memorize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Memory.html#Memory.memorize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory.memorize" title="Permalink to this definition">#</a></dt>
<dd><p>Memorizes the provided variable value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Variable</span></code>, required) – The variable for which we want to memorize a value.</p></li>
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bitarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, required) – The value to memorize.</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">variable</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;var1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
<span class="go">Data (String(nbChars=(0,8192))) from field &#39;None&#39;: b&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
<span class="go">Data (String(nbChars=(0,8192))) from field &#39;None&#39;: b&#39;test&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<p>In the API, the ability to specify relationships between successive
messages or between messages and the environment is provided by the
<a class="reference internal" href="#netzob.Model.Vocabulary.Domain.Variables.Memory.Memory" title="netzob.Model.Vocabulary.Domain.Variables.Memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a> class.</p>
<p><strong>Relationships between fields of successive messages</strong></p>
<p>The following example shows how to define a relationship between a
received message and the next message to send. A memory is used to store the value of each variable. During the first call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> on the <code class="docutils literal notranslate"><span class="pre">s1</span></code> symbol, the value associated to the field <code class="docutils literal notranslate"><span class="pre">f3</span></code> is notably stored in memory, so that it can be retrieved when calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">specialize()</span></code> on the <code class="docutils literal notranslate"><span class="pre">s2</span></code> symbol:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;S1&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;master&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="n">f3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F6&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f4</span><span class="p">,</span> <span class="n">f5</span><span class="p">,</span> <span class="n">f6</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;hello;&quot;</span><span class="p">):]</span> <span class="o">==</span> <span class="n">m2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;master&gt;&quot;</span><span class="p">):]</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Relationships between a message field and the environment</strong></p>
<p>The following example shows how to define a relationship between a
message to send and an environment variable. The symbol is first
defined, and then an environment variable is created. The first step
consists in overloading the definition domain of the <code class="docutils literal notranslate"><span class="pre">f9</span></code> field to
link the environment variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Symbol definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;master&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F7&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F8&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;F9&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f7</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">f9</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Environment variables definition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;env1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span><span class="o">.</span><span class="n">memorize</span><span class="p">(</span><span class="n">env1</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="s2">&quot;John&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overloading f9 field definition to link the environment variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="n">env1</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Symbol specialization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s3</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">))</span>
<span class="go">b&#39;master&gt;John&#39;</span>
</pre></div>
</div>
</section>
<section id="persistence-during-specialization-and-abstraction-of-symbols">
<h2>Persistence during Specialization and Abstraction of Symbols<a class="headerlink" href="#persistence-during-specialization-and-abstraction-of-symbols" title="Permalink to this headline">#</a></h2>
<p>The values of variables defined in fields can have different assignment strategies, depending on their persistence and lifecycle.</p>
<p>The Scope class provides a description of those strategies, along with some examples.</p>
<dl class="py class">
<dt class="sig sig-object py" id="netzob.Model.Vocabulary.Domain.Variables.Scope.Scope">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Scope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netzob/Model/Vocabulary/Domain/Variables/Scope.html#Scope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netzob.Model.Vocabulary.Domain.Variables.Scope.Scope" title="Permalink to this definition">#</a></dt>
<dd><p>This class represents the Assignment Strategy of a variable.</p>
<p>The scope of a variable defines how its value is used while
abstracting and specializing, and therefore impacts the
memorization strategy.</p>
<p>A scope strategy can be attached to a variable and is used both
when abstracting and specializing. A scope strategy describes the
set of memory operations that must be performed each time a
variable is abstracted or specialized. These operations can be
separated into two groups: those used during the abstraction and
those used during the specialization.</p>
<p>The available scope strategies for a variable are:</p>
<ul class="simple">
<li><p>Scope.SESSION</p></li>
<li><p>Scope.MESSAGE</p></li>
<li><p>Scope.NONE (the default strategy for variables)</p></li>
</ul>
<p>Those strategies are explained below. In addition, some following
examples are shown in order to understand how the strategies can
be applied during abstraction and specialization of Field with
Data variables.</p>
<ul>
<li><p><strong>Scope.SESSION</strong>: This kind of variable carries a value, such as
a session identifier, generated and memorized during its first
specialization and reused as such in the remainder of the
session. Conversely, the first time a Session Scope field is
abstracted, the value of its variable is not defined and the received
value is saved. Later in the session, if this field is
abstracted again, the corresponding variable is then defined and
we compare the received field value against the memorized one.</p>
<p>The following example shows the <strong>abstraction and specialization of data with Session Scope</strong>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">SESSION</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;SZ,1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;SZ,1&#39;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;SZ,1&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;SZ,1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;S0&#39;, cannot abstract the data: &#39;b&#39;test&#39;&#39;. Error: &#39;No parsing path returned while parsing &#39;b&#39;test&#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">SESSION</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;john&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">netzob.Model.Vocabulary.AbstractField.AbstractionException</span>: <span class="n">With the symbol/field &#39;S0&#39;, cannot abstract the data: &#39;b&#39;test&#39;&#39;. Error: &#39;No parsing path returned while parsing &#39;b&#39;test&#39;&#39;&#39;</span>
</pre></div>
</div>
</li>
<li><p><strong>Scope.MESSAGE</strong>: With this kind of variable, the value is
generated and then memorized during the first specialization and
is always memorized during abstraction. For further specialization, the value is taken from memory. However, in contrary to
the Session Scope, no comparison is made during abstraction with
the current memorized value (i.e. the received value is always memorized). For example, the IRC <cite>nick</cite> command
corresponds to a Message Scope, that denotes the new nick name
of the user. This nick name can afterwards be used in other
fields, but whenever a NICK command is emitted, its value is
regenerated.</p>
<p>The following example shows the <strong>abstraction and specialization of data with Message Scope</strong>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">MESSAGE</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;X!z@&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;john&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;john&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">MESSAGE</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;john&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;kurt&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;kurt&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;kurt&#39;</span>
</pre></div>
</div>
</li>
<li><p><strong>Scope.NONE</strong>: This kind of variable denotes a value which
changes whenever it is specialized and is never
memorized. The abstraction
process of such a field only verifies that the received value
complies with the field definition domain without memorizing
it. For example, a size field or a CRC field should have such a scope.</p>
<p>The following example shows the <strong>abstraction and specializaion of data without persistence</strong>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">NONE</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;4%!F&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;v\tK5&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netzob.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">Data</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">nbChars</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="n">Scope</span><span class="o">.</span><span class="n">NONE</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;john&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">))</span>
<span class="go">b&#39;h:JM&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="s2">&quot;kurt&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">OrderedDict([(&#39;f1&#39;, b&#39;kurt&#39;)])</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../installation/python.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Installation of Netzob</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="statemachinespec.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">State Machine Modeling</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
      &copy; Copyright 2011-2022, Frédéric Guihéry, Georges Bossert.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>