
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Overview of Netzob &#8212; Netzob Documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/zoby.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Netzob Documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Netzob documentation
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Installation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../installation/python.html">
   Installation of Netzob
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Protocol Modelization
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/dataspec.html">
   Format Message Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/statemachinespec.html">
   State Machine Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/protospec.html">
   Protocol Modeling
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Traffic Generation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/trafficgeneration.html">
   Sending and Receiving Messages
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/actor.html">
   Visiting a State Machine with an Actor
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fuzzing
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/fuzzing.html">
   Fuzzing Message Format
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../language_specification/fuzzing_automata.html">
   Fuzzing Automata
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/overview/index.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#import-and-capture-data">
   Import and capture data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#inferring-message-format-and-state-machine-with-netzob">
   Inferring message format and state machine with Netzob
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-1-clustering-messages-and-partitioning-in-fields">
     Step 1: clustering Messages and Partitioning in Fields
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-2-characterization-of-fields">
     Step 2 : characterization of Fields
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-3-inferring-the-transition-graph-of-the-protocol">
     Step 3: inferring the Transition Graph of the Protocol
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#protocol-simulation">
   Protocol simulation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#smart-fuzzing-with-netzob">
   Smart fuzzing with Netzob
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#export-protocol-model">
   Export protocol model
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Overview of Netzob</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#import-and-capture-data">
   Import and capture data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#inferring-message-format-and-state-machine-with-netzob">
   Inferring message format and state machine with Netzob
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-1-clustering-messages-and-partitioning-in-fields">
     Step 1: clustering Messages and Partitioning in Fields
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-2-characterization-of-fields">
     Step 2 : characterization of Fields
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-3-inferring-the-transition-graph-of-the-protocol">
     Step 3: inferring the Transition Graph of the Protocol
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#protocol-simulation">
   Protocol simulation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#smart-fuzzing-with-netzob">
   Smart fuzzing with Netzob
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#export-protocol-model">
   Export protocol model
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="overview-of-netzob">
<span id="overview"></span><h1>Overview of Netzob<a class="headerlink" href="#overview-of-netzob" title="Permalink to this headline">#</a></h1>
<p>Netzob has been initiated by security auditors of
<a class="reference external" href="http://www.amossys.fr">AMOSSYS</a> and the <a class="reference external" href="http://www.rennes.supelec.fr/ren/rd/cidre/">CIDre research team of
Supélec</a> to address the
reverse engineering of communication protocols.</p>
<p>Originaly, the development of Netzob has been initiated to support
security auditors and evaluators in their activities of modeling and
simulating undocumented protocols. The tool has then been extended to
allow smart fuzzing of unknown protocol.</p>
<p>The following picture depicts the main modules of Netzob:</p>
<figure class="align-center" id="id1">
<img alt="Architecture of Netzob" src="http://www.netzob.org/img/overview_archi.png" />
<figcaption>
<p><span class="caption-text">Architecture of Netzob</span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p><strong>Import module:</strong> Data import is available in two ways: either by
leveraging the channel-specific captors (currently network and IPC –
Inter-Process Communication), or by using specific importers (such as
PCAP files, structured files and OSpy files).</p></li>
<li><p><strong>Protocol inference modules:</strong> The vocabulary and grammar inference
methods constitute the core of Netzob. It provides both passive and
active reverse engineering of communication flows through automated
and manuals mechanisms.</p></li>
<li><p><strong>Simulation module:</strong> Given vocabulary and grammar models previously
inferred, Netzob can understand and generate communication traffic
between multiple actors. It can act as either a client, a server or
both.</p></li>
<li><p><strong>Export module:</strong> This module permits to export an inferred model of
a protocol in formats that are understandable by third party software
or by a human. Current work focuses on export format compatible with
main traffic dissectors (Wireshark and Scapy) and fuzzers (Peach and
Sulley).</p></li>
</ul>
<p>And here is a screenshot of the main graphical interface:</p>
<figure class="align-center">
<img alt="" src="https://dev.netzob.org/attachments/96/netzob_UI.png" />
</figure>
<p>The following sections will describe in more details the available
mechanisms.</p>
<section id="import-and-capture-data">
<h2>Import and capture data<a class="headerlink" href="#import-and-capture-data" title="Permalink to this headline">#</a></h2>
<p>The first step in the inferring process of a protocol in Netzob is to
capture and to import messages as samples. There are different methods
to retrieve messages depending of the communication channel used (files,
network, IPC, USB, etc.) and the format (PCAP, hex, raw binary flows,
etc.).</p>
<p>The figure below describes the multiple communication channels and
therefore possible sniffing point’s Netzob aims at addressing.</p>
<figure class="align-center" id="id2">
<img alt="Multiple communication flows arround an application" src="http://www.netzob.org/img/overview_multipleFlows.png" />
<figcaption>
<p><span class="caption-text">Multiple communication flows arround an application</span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The current version (version 0.4) of Netzob deals with the following
data sources :</p>
<ul class="simple">
<li><p><strong>Live network communications</strong></p></li>
<li><p><strong>Captured network communications</strong> (PCAPs)</p></li>
<li><p><strong>Inter-Process Communications</strong> (IPCs)</p></li>
<li><p><strong>Text and binary files</strong></p></li>
<li><p><strong>API flows</strong> through <a class="reference external" href="http://code.google.com/p/ospy/">oSpy</a> file
format support</p></li>
</ul>
<p>Otherwise, if you plan to reverse a protocol implemented over an
supported communication channel, Netzob’s can manipulates any
communications flow through an XML representation. Therefore, this
situation only requires a specific development to capture the targeted
flow and to save it using a compatible XML.</p>
<figure class="align-center" id="id3">
<a class="reference internal image-reference" href="http://www.netzob.org/img/overview_extraImport.png"><img alt="Importing data from an unknown communication channel using the XML definition" src="http://www.netzob.org/img/overview_extraImport.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-text">Importing data from an unknown communication channel using the XML
definition</span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="inferring-message-format-and-state-machine-with-netzob">
<h2>Inferring message format and state machine with Netzob<a class="headerlink" href="#inferring-message-format-and-state-machine-with-netzob" title="Permalink to this headline">#</a></h2>
<p>The vocabulary of a communication protocol defines all the words which
are integrated in it. For example, the vocabulary of a malware’s
communication protocol looks like a set of possible commands : {“attack
<a class="reference external" href="http://www.google.fr">www.google.fr</a>”, “dnspoison
this.dns.server.com”, “execute ‘uname -a’”, …}. Another example of a
vocabulary is the set of valids words in the HTTP protocol : { “GET
/images/logo.png HTTP/1.1 …”, “HTTP/1.1 200 OK …”, …}.</p>
<p>Netzob’s vocabulary inferring process has been designed in order to
retrieve the set of all possible words used in a targeted protocol and
to identify their structures. Indeed words are made of different fields
which are defined by their value and types. Hence a word can be
described using the structure of its fields.</p>
<p>We describe the learning process implemented in Netzob to
semi-automatically infer the vocabulary and the grammar of a protocol.
This process, illustrated in the following picture, is performed in
three main steps:</p>
<ol class="arabic simple">
<li><p><strong>Clustering messages and partitioning these messages in fields.</strong></p></li>
<li><p><strong>Characterizing message fields and abstracting similar messages in
symbols.</strong></p></li>
<li><p><strong>Inferring the transition graph of the protocol.</strong></p></li>
</ol>
<figure class="align-center" id="id4">
<a class="reference internal image-reference" href="http://www.netzob.org/img/overview_inferenceSteps.png"><img alt="The main functionalities" src="http://www.netzob.org/img/overview_inferenceSteps.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-text">The main functionalities</span><a class="headerlink" href="#id4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="step-1-clustering-messages-and-partitioning-in-fields">
<h3>Step 1: clustering Messages and Partitioning in Fields<a class="headerlink" href="#step-1-clustering-messages-and-partitioning-in-fields" title="Permalink to this headline">#</a></h3>
<p>To discover the format of a symbol, Netzob supports different
partitioning approaches. In this article we describe the most accurate
one, that leverages sequence alignment processes. This technique permits
to align invariants in a set of messages. The <a class="reference external" href="http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Needleman-Wunsh
algorithm</a>
performs this task optimally. Needleman-Wunsh is particularly effective
on protocols where dynamic fields have variable lengths (as shown on the
following picture).</p>
<figure class="align-center" id="id5">
<img alt="Sequence alignment with Needleman-Wunsh algorithm" src="http://www.netzob.org/img/overview_needleman.png" />
<figcaption>
<p><span class="caption-text">Sequence alignment with Needleman-Wunsh algorithm</span><a class="headerlink" href="#id5" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>When partitioning and clustering processes are done, we obtain a
relevant first approximation of the overall message formats. The next
step consists in determining the characteristics of the fields.</p>
<p>If the size of those fields is fixed, as in TCP and IP headers, it is
preferable to apply a basic partitioning, also provided by Netzob. Such
partitioning works by aligning each message by the left, then
separating successive fixed columns from successive dynamic columns.</p>
<p>To regroup aligned messages by similarity, the Needleman-Wunsh algorithm
is used in conjunction with a clustering algorithm. The applied
algorithm is <a class="reference external" href="http://en.wikipedia.org/wiki/UPGMA">UPGMA</a>.</p>
</section>
<section id="step-2-characterization-of-fields">
<h3>Step 2 : characterization of Fields<a class="headerlink" href="#step-2-characterization-of-fields" title="Permalink to this headline">#</a></h3>
<p>The field type identification partially derives from the partitioning
inference step. For fields containing only invariants, the type merely
corresponds to the invariant value. For other fields, the type is
automatically materialized, in first approximation, with a regular
expression, as shown on next figure. This form enables easy validation of
the data compliance with a specific type. Moreover, Netzob offers the
possibility to visualize the definition domain of a field. This helps to
manually refine the type associated with a field.</p>
<figure class="align-center" id="id6">
<img alt="Characterization of field type" src="http://www.netzob.org/img/overview_fieldType.png" />
<figcaption>
<p><span class="caption-text">Characterization of field type</span><a class="headerlink" href="#id6" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Some intra-symbol dependencies are automatically identified. The size
field, present in many protocol formats, is an example of intra-symbol
dependency. A search algorithm has been designed to look for potential
size fields and their associated payloads. By extension, this technique
permits to discover encapsulated protocol payloads.</p>
<p>Environmental dependencies are also identified by looking for specific
values retrieved during message capture. Such specific values consist of
characteristics of the underlying hardware, operating system and network
configuration. During the dependency analysis, these characteristics are
searched in various encoding.</p>
</section>
<section id="step-3-inferring-the-transition-graph-of-the-protocol">
<h3>Step 3: inferring the Transition Graph of the Protocol<a class="headerlink" href="#step-3-inferring-the-transition-graph-of-the-protocol" title="Permalink to this headline">#</a></h3>
<p>The third step of the learning process discovers and extracts the
transition graph from a targeted protocol (also called the grammar).
More formally, the grammar of a communication protocol defines the set
of valid sentences which can be produced by a communication. A sentence
is a sorted set of words which may be received or emmited by a protocol
handler. An exemple of a simple sentence is :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;attack www.google.fr&quot;</span><span class="p">,</span> <span class="s2">&quot;attack has failed&quot;</span><span class="p">,</span> <span class="s2">&quot;attack www.kernel.org&quot;</span><span class="p">,</span> <span class="s2">&quot;root access granted.&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>which can be described using the following simple automata with S0 the
initial state :</p>
<figure class="align-center" id="id7">
<img alt="Schema of a simple grammar" src="http://www.netzob.org/img/overview_exampleSimpleGrammar.png" />
<figcaption>
<p><span class="caption-text">Schema of a simple grammar</span><a class="headerlink" href="#id7" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The learning process step is achieved by a set of active experiments
that stimulate a real client or server implementation using successive
sequences of input symbols and analyze its responses.</p>
<p>In Netzob, the automata used to represent or model a communication
protocol is an extended version of a Mealy automata which includes
semi-stochastic transitions, contextualized and parametrized inputs and
outputs. The first academic presention of this model is included in a
dedicated scientific paper provided in the documentation section.</p>
<p>The model is inferred through a dedicated <strong>active</strong> process which
consists in stimulating an implementation and to analyze its responses.
In this process, we use the previously infered vocabulary to discover
and to learn the grammar of the communication protocol. Each stimulation
is computed following an extension of the <strong>Angluin L</strong> algorithm*.</p>
</section>
</section>
<section id="protocol-simulation">
<h2>Protocol simulation<a class="headerlink" href="#protocol-simulation" title="Permalink to this headline">#</a></h2>
<p>One of our main goal is to generate realistic network traffic from
undocummented protocols. Therefore, we have implemented a dedicated
module that, given vocabulary and grammar models previously infered, can
simulate a communication protocol between multiple bots and masters.
Besides their use of the same model, each actors is independent from the
others and is organized around three main stages.</p>
<p>The first stage is a dedicated library that reads and writes from the
network channel. It also parses the flow in messages according to
previous protocols layers. The second stage uses the vocabulary to
abstract received messages into symbols and vice-versa to specialize
emitted symbols into messages. A memory buffer is also available to
manage dependency relations. The last stage implements the grammar model
and computes which symbols must be emitted or received according to the
current state and time.</p>
</section>
<section id="smart-fuzzing-with-netzob">
<h2>Smart fuzzing with Netzob<a class="headerlink" href="#smart-fuzzing-with-netzob" title="Permalink to this headline">#</a></h2>
<p>A typical example of dynamic vulnerability analysis is the robustness
tests. It can be used to reveal software programming errors which can
leads to software security vulnerabilities. These tests provide an
efficient and almost automated solution to easily identify and study
exposed surfaces of systems. Nevertheless, to be fully efficient, the
fuzzing approaches must cover the complete definition domain and
combination of all the variables which exist in a protocol (IP adresses,
serial numbers, size fields, payloads, message identifer, etc.). But
fuzzing typical communication interface requires too many test cases due
to the complex variation domains introduced by the semantic layer of a
protocol. In addition to this, an efficient fuzzing should also cover
the state machine of a protocol which also brings another huge set of
variations. The necessary time is nearly always too high and therefore
limits the efficiency of this approach.</p>
<p>With all these contraints, achieving robustness tests on a target is
feasible only if the expert has access to a specially designed tool for
the targeted protocol. Hence the emergence of a large number of tools to
verify the behavior of an application on one or more communication
protocols. However in the context of proprietary communications
protocols for which no specifications are published, fuzzers do not
provide optimal results.</p>
<p>Netzob helps the security evaluator by simplifying the creation of a
dedicated fuzzer for a proprietary or undocumented protocol. It provides
to the expert means to execute a semi-automated inferring process to create a
model of the targeted protocol. This model can afterward be refined by
the evaluator. Finally, the created model is included in the fuzzing
module of Netzob which considers the vocabulary and the grammar of the
protocol to generate optimized and specific test cases. Both mutation
and generation are available for fuzzing.</p>
</section>
<section id="export-protocol-model">
<h2>Export protocol model<a class="headerlink" href="#export-protocol-model" title="Permalink to this headline">#</a></h2>
<p>The following export formats are currently provided by Netzob:</p>
<ul class="simple">
<li><p>XML format</p></li>
<li><p>human readable (Wireshark like)</p></li>
<li><p>Peach fuzzer export: this enables efficiency combination of Peach
Fuzzer on previously undocumented protocols.</p></li>
</ul>
<p>Besides, you can write your own exporter to manipulate the inferred
protocol model in your favorite tool.</p>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
      &copy; Copyright 2011-2022, Frédéric Guihéry, Georges Bossert.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>